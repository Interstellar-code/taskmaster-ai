{
  "tasks": [
    {
      "id": 1,
      "title": "Implement CLI Entry Point for Interactive Menu",
      "description": "Implement the core command-line interface entry point for the interactive menu system, allowing users to launch it using `task-hero --menu`, `task-hero -m`, or `task-hero menu`.",
      "details": "Utilize Commander.js to define the `--menu`, `-m`, and `menu` options. This should trigger the initialization of the interactive menu system. Ensure backward compatibility with existing commands. The entry point should call a main menu rendering function.",
      "testStrategy": "Verify that `task-hero --menu`, `task-hero -m`, and `task-hero menu` successfully launch the interactive menu. Test that existing commands still function correctly when the menu is not invoked.",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Integrate Commander.js and Define Base Command",
          "description": "Set up Commander.js in the main CLI entry file (e.g., `index.js` or `cli.js`) and define the base `task-hero` command. This subtask focuses on initializing the CLI framework.",
          "dependencies": [],
          "details": "Install Commander.js. In the main CLI file, import Commander and initialize `program`. Set the program's name and version. Ensure `program.parse(process.argv)` is called at the end of the file.",
          "status": "done",
          "testStrategy": "Run `node your-cli-file.js --version` and `node your-cli-file.js --help` to verify Commander.js is active and displays basic info.",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Implement 'menu' Command and Options",
          "description": "Add the `menu` command and its corresponding short (`-m`) and long (`--menu`) options to the Commander.js program. This command/option should be distinct from other existing commands.",
          "dependencies": [
            1
          ],
          "details": "Use `program.command('menu')` or `program.option('-m, --menu', 'Launch interactive menu')`. If using `program.command('menu')`, ensure it has a description. If using `program.option`, its action should be defined to trigger the menu logic. Ensure it doesn't conflict with existing commands.",
          "status": "done",
          "testStrategy": "Run `task-hero menu --help` and `task-hero --help` to confirm the 'menu' command/option is listed correctly. Verify `task-hero --menu` and `task-hero -m` don't throw immediate errors.",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Create Placeholder Menu Initialization Function",
          "description": "Develop a placeholder function (e.g., `initializeInteractiveMenu`) that will be called when the `menu` command or options are invoked. This function will initially just log a message.",
          "dependencies": [
            2
          ],
          "details": "Create a new file (e.g., `src/menu/index.js`) or a function within the main CLI file. This function should simply `console.log('Initializing interactive menu...')`. Call this function from the action handler of the `menu` command/option defined in subtask 2.",
          "status": "done",
          "testStrategy": "Run `task-hero menu`, `task-hero --menu`, and `task-hero -m`. Verify that 'Initializing interactive menu...' is printed to the console for each invocation.",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Ensure Backward Compatibility with Existing Commands",
          "description": "Verify that the addition of the new `menu` command/options does not break or alter the behavior of any pre-existing CLI commands (e.g., `task-hero add`, `task-hero list`).",
          "dependencies": [
            3
          ],
          "details": "Review the existing Commander.js setup for other commands. Ensure that `program.parse()` correctly dispatches to existing command handlers when the `menu` command/option is not present. No changes should be required for existing commands, but their functionality must be confirmed.",
          "status": "done",
          "testStrategy": "Execute a few existing commands (e.g., `task-hero add 'Test task'`, `task-hero list`). Confirm they function exactly as before, without any interference from the new menu logic.",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Refactor and Integrate Menu Entry Point",
          "description": "Finalize the integration by ensuring the menu initialization logic is properly encapsulated and called. This includes ensuring the `initializeInteractiveMenu` function is correctly imported and invoked, and that the CLI structure is clean.",
          "dependencies": [
            4
          ],
          "details": "If `initializeInteractiveMenu` was in the main CLI file, move it to a dedicated module (e.g., `src/menu/index.js`) and import it. Ensure the `menu` command/option's action handler correctly calls this imported function. Add comments for clarity. The entry point should be robust and ready to call the actual menu rendering logic in future tasks.",
          "status": "done",
          "testStrategy": "Perform a comprehensive test: run `task-hero menu`, `task-hero --menu`, `task-hero -m`, and several existing commands. All should execute successfully and produce the expected output, confirming both new and old functionalities are intact and integrated cleanly.",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 2,
      "title": "Develop Core Menu Framework and UI",
      "description": "Develop the foundational framework for the interactive menu using `inquirer.js` for prompts and `chalk` and `boxen` for visual styling. This includes rendering the main menu structure, handling user input for navigation, and displaying basic project status.",
      "details": "Design the main menu interface as specified in the PRD, including the header with project name, task counts, and status. Use `inquirer.js` for numbered menu options and input handling. Implement `chalk` for colors and `boxen` for borders to achieve the specified visual hierarchy. Ensure the menu persists after an action and returns to the main menu. Implement a basic loop for menu interaction.",
      "testStrategy": "Launch the menu and verify its visual appearance matches the PRD. Test selecting valid and invalid options, ensuring the menu loops correctly and handles invalid input gracefully. Verify the display of project information (placeholder values initially).",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up Project Structure and Basic Dependencies",
          "description": "Initialize the project, install core dependencies (`inquirer`, `chalk`, `boxen`), and create a basic entry point file to ensure the environment is ready for menu development.",
          "dependencies": [],
          "details": "Create a new Node.js project. Install `inquirer`, `chalk`, and `boxen` as production dependencies. Create an `index.js` or `app.js` file. Add a simple 'Hello World' console log to verify execution.",
          "status": "done",
          "testStrategy": "Run `node index.js` and verify 'Hello World' output. Check `package.json` for installed dependencies.",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Implement Main Menu Structure and Styling",
          "description": "Develop the visual layout of the main menu, including the header with project name, task counts, and status, using `chalk` for colors and `boxen` for borders.",
          "dependencies": [
            1
          ],
          "details": "Create a function, e.g., `renderMainMenuHeader()`, that takes project name, total tasks, and completed tasks as arguments. Use `chalk` to colorize text (e.g., project name, status). Use `boxen` to draw a border around the header content. For initial testing, hardcode placeholder values for project name and task counts.",
          "status": "done",
          "testStrategy": "Call `renderMainMenuHeader()` with sample data. Visually inspect the console output to ensure correct colors, borders, and layout as per PRD.",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Integrate Inquirer for Menu Options and Input",
          "description": "Implement the interactive menu options using `inquirer.js`, allowing users to select actions. This subtask focuses on displaying the options and capturing user input.",
          "dependencies": [
            2
          ],
          "details": "Create a function, e.g., `promptMainMenu()`, that uses `inquirer.prompt` with a `list` type. Define at least 3-4 placeholder menu options (e.g., 'View Tasks', 'Add Task', 'Exit'). Ensure the prompt is displayed below the header rendered in the previous step. Capture the user's choice.",
          "status": "done",
          "testStrategy": "Run the application. Verify that the menu options are displayed correctly. Select an option and confirm that the choice is logged to the console.",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Implement Main Menu Loop and Basic Navigation",
          "description": "Create the core application loop that continuously displays the main menu, processes user input, and returns to the menu after an action, until the user chooses to exit.",
          "dependencies": [
            3
          ],
          "details": "Wrap the menu rendering and prompting logic within an asynchronous `while` loop. Implement a `switch` or `if/else if` statement to handle different user choices. For non-exit choices, simply log a message indicating the selected action (e.g., 'Viewing tasks...') and then re-render the menu. The loop should break when the 'Exit' option is chosen.",
          "status": "done",
          "testStrategy": "Run the application. Select various options and verify that the corresponding action message is displayed, and the menu reappears. Select 'Exit' and confirm the application terminates.",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Refine Styling and Placeholder Status Integration",
          "description": "Apply final styling adjustments to the entire menu, ensuring consistency. Integrate dynamic (placeholder) project status and task counts into the header, simulating real data.",
          "dependencies": [
            4
          ],
          "details": "Review the PRD for specific color schemes, padding, and border styles for both the header and potentially the menu options. Adjust `chalk` and `boxen` parameters accordingly. Create simple placeholder variables for 'project name', 'total tasks', and 'completed tasks' (e.g., `const projectName = 'My Project'; const totalTasks = 10; const completedTasks = 3;`). Pass these variables to the `renderMainMenuHeader()` function.",
          "status": "done",
          "testStrategy": "Run the application. Visually inspect the entire menu for adherence to design specifications. Change the placeholder task counts and verify that the header updates correctly on subsequent menu renders.",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 3,
      "title": "Integrate Project Management and Task Operations Menus",
      "description": "Implement the 'Project Management' and 'Task Operations' menu categories, mapping their respective numbered options to the existing `task-hero` commands. This involves integrating the menu selections with the underlying command execution logic.",
      "details": "Create sub-menus for 'Project Management' (init, parse-prd, models) and 'Task Operations' (list, next, show, set-status, generate). Map each menu option to its corresponding `task-hero` command. When a command is selected, execute it and ensure control returns to the menu after completion. Utilize the existing `scripts/modules/commands.js` infrastructure.",
      "testStrategy": "Navigate to 'Project Management' and 'Task Operations' menus. Select each command option and verify that the correct `task-hero` command is executed. Confirm that the menu reappears after command execution. Test 'Back to Main Menu' functionality.",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Define Menu Structure and Command Mappings",
          "description": "Create a data structure (e.g., a JavaScript object or array) that defines the 'Project Management' and 'Task Operations' menu categories, their display names, and the mapping of each numbered option to its corresponding `task-hero` command name.",
          "dependencies": [],
          "details": "Define a clear, maintainable data structure, possibly in a new module like `scripts/modules/menu_definitions.js`. Each menu item should include its display text, the associated command name, and potentially a short description. Ensure the command names precisely match those expected by `task-hero`.",
          "status": "done",
          "testStrategy": "Manually inspect the defined data structure to ensure correctness and completeness of menu items and command mappings.",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Implement Menu Display Logic",
          "description": "Develop a function or module responsible for displaying the defined menu structure to the user, including categories and numbered options. This function should take the menu definition as input and print it to the console.",
          "dependencies": [
            1
          ],
          "details": "Create a function, perhaps `displayMenu(menuStructure)`, that iterates through the menu categories and their options, printing them in a user-friendly format. Use `console.log` for output. Ensure clear numbering for each option.",
          "status": "done",
          "testStrategy": "Run the menu display function and visually verify that all categories and options are displayed correctly and are properly numbered according to the defined structure.",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Implement User Input and Command Selection Logic",
          "description": "Develop logic to prompt the user for a menu selection, read their input, and validate it against the available options. Once a valid selection is made, identify the corresponding `task-hero` command.",
          "dependencies": [
            1,
            2
          ],
          "details": "Use `readline` or similar module for input. Implement a loop that repeatedly prompts the user until valid input (a number corresponding to an existing menu option) is received. Map the selected number back to the command name using the data structure defined in subtask 1. Handle invalid input gracefully.",
          "status": "done",
          "testStrategy": "Manually test by entering valid numbers for various options, invalid numbers, and non-numeric input. Verify that the correct command name is identified for valid inputs and that error messages are displayed for invalid inputs.",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Integrate Command Execution and Return to Menu",
          "description": "Connect the selected command from subtask 3 with the existing `task-hero` command execution logic (likely in `scripts/modules/commands.js`). After the command completes, ensure control returns to the main menu display.",
          "dependencies": [
            3
          ],
          "details": "Call the appropriate function from `scripts/modules/commands.js` with the identified command name and any necessary arguments. Wrap the command execution in a `try-catch` block for error handling. After execution (or error), re-display the menu (calling the function from subtask 2) to allow further selections.",
          "status": "done",
          "testStrategy": "Select various menu options (e.g., 'list', 'next', 'init'). Verify that the corresponding `task-hero` command executes as expected and that the menu is redisplayed immediately after the command finishes.",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Refine User Experience and Error Handling",
          "description": "Enhance the overall user experience by adding clear prompts, confirmation messages, and robust error handling for command execution failures or unexpected scenarios.",
          "dependencies": [
            4
          ],
          "details": "Add clear instructions for menu navigation. Implement specific error messages for command failures, perhaps by catching exceptions from `scripts/modules/commands.js`. Consider adding a 'back' or 'exit' option to the menu. Ensure consistent formatting for all console output.",
          "status": "done",
          "testStrategy": "Test edge cases: try to execute commands that might fail (e.g., `set-status` with an invalid ID). Verify that user prompts are clear, error messages are informative, and the application remains stable. Test the 'exit' functionality if implemented.",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 4,
      "title": "Integrate Task Management and Subtask Operations Menus",
      "description": "Implement the 'Task Management' and 'Subtask Operations' menu categories, ensuring seamless integration with existing `task-hero` commands and handling of required parameters.",
      "details": "Develop sub-menus for 'Task Management' (add-task, update-task, update, remove-task, move) and 'Subtask Operations' (add-subtask, update-subtask, remove-subtask, expand, clear-subtasks). For commands requiring parameters (e.g., `add-task <name>`), use `inquirer.js` to prompt the user for input. Implement smart defaults based on project context where applicable. Ensure command output is displayed within the menu interface.",
      "testStrategy": "Navigate to 'Task Management' and 'Subtask Operations' menus. Select commands that require parameters and verify that the system prompts for input correctly. Test with valid and invalid inputs. Confirm that command output is visible and the menu returns afterwards.",
      "priority": "medium",
      "dependencies": [
        3
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Define and Structure Menu Categories and Commands",
          "description": "Establish the foundational data structure for the 'Task Management' and 'Subtask Operations' menu categories, including their respective commands and metadata (e.g., command name, description, required parameters). This will serve as the blueprint for menu generation.",
          "dependencies": [],
          "details": "Create a JavaScript object or array structure that maps menu categories to an array of command objects. Each command object should specify its `command` (e.g., 'add-task'), `description`, and an array of `parameters` (e.g., `[{ name: 'name', type: 'string', required: true }]`). This structure will be used by the menu rendering logic.",
          "status": "done",
          "testStrategy": "Verify that the data structure correctly defines all specified commands and their parameters for both 'Task Management' and 'Subtask Operations' categories.",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Implement Inquirer.js Parameter Prompting Utility",
          "description": "Develop a reusable utility function that leverages `inquirer.js` to dynamically prompt the user for command parameters based on the metadata defined in Subtask 1. This utility will be invoked when a command requiring input is selected.",
          "dependencies": [
            1
          ],
          "details": "Create a function, e.g., `promptForParameters(parametersArray)`, that takes an array of parameter definitions (from Subtask 1's data structure) and uses `inquirer.js` to generate appropriate prompts (e.g., input, list, confirm). It should return a promise resolving with an object containing the user's inputs. Handle different parameter types (string, number, boolean) and implement basic validation for required fields.",
          "status": "done",
          "testStrategy": "Test the utility with various parameter configurations (e.g., single required string, multiple mixed types, optional parameters) to ensure correct prompting and input capture. Simulate user input for automated testing.",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Integrate Menu Navigation and Command Execution Logic",
          "description": "Develop the core menu navigation logic that presents the 'Task Management' and 'Subtask Operations' categories, allows users to select commands, and then executes the corresponding `task-hero` command, utilizing the parameter prompting utility.",
          "dependencies": [
            1,
            2
          ],
          "details": "Use `inquirer.js` to present the main menu categories. Upon category selection, present the list of commands within that category. When a command is selected, check its parameter requirements. If parameters are needed, call the utility from Subtask 2. Once parameters are gathered (or if none are needed), dynamically construct and execute the `task-hero` command (e.g., `task-hero add-task 'Task Name'`). Ensure command output is captured and displayed back to the user within the menu interface.",
          "status": "done",
          "testStrategy": "Manually test navigation through both menu categories, selecting various commands. Verify that parameter prompts appear correctly and that the underlying `task-hero` commands are executed with the provided inputs. Check that command output is displayed.",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Implement Smart Defaults and Contextual Parameter Handling",
          "description": "Enhance the parameter prompting utility and command execution logic to incorporate smart defaults based on the current project context or previously used values, improving user experience.",
          "dependencies": [
            3
          ],
          "details": "For commands like `add-task` or `add-subtask`, consider implementing smart defaults. For example, if a project is currently active, default the project name. For `update` commands, pre-fill current values if available. This might involve querying the `task-hero` state or maintaining a simple context store. Modify the `promptForParameters` utility to accept and utilize default values for prompts.",
          "status": "done",
          "testStrategy": "Test commands with smart defaults (e.g., `add-task` when a project is active, `update-task` for an existing task). Verify that default values are correctly pre-filled in prompts and can be overridden by the user.",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Refine User Experience and Error Handling",
          "description": "Improve the overall user experience by adding robust error handling, clear feedback messages, and graceful exit options within the menu interface.",
          "dependencies": [
            4
          ],
          "details": "Implement `try-catch` blocks around command executions to gracefully handle errors returned by `task-hero` or during parameter prompting. Display user-friendly error messages instead of raw exceptions. Provide clear success messages after command completion. Ensure a 'Back' or 'Exit' option is available at appropriate menu levels to allow users to navigate or quit the application cleanly. Consider adding input validation beyond just 'required' checks (e.g., format validation for IDs).",
          "status": "done",
          "testStrategy": "Test error scenarios (e.g., attempting to remove a non-existent task, providing invalid input format). Verify that error messages are clear and that the application doesn't crash. Test navigation back through menus and the exit functionality.",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 5,
      "title": "Integrate Analysis, Help, and Settings Menus",
      "description": "Implement the 'Analysis & Dependencies', 'Help & Information', and 'Settings' menu categories, integrating them with their respective functionalities and ensuring proper context awareness.",
      "details": "Create sub-menus for 'Analysis & Dependencies' (analyze-complexity, complexity-report, add-dependency, remove-dependency, validate-dependencies, fix-dependencies), 'Help & Information' (Command Reference, Quick Start Guide, Keyboard Shortcuts), and 'Settings' (Toggle Research Mode, Set Default File Paths, Debug Mode). For 'Settings', ensure integration with `.taskmasterconfig` for reading and updating settings. Implement contextual help and suggestions where appropriate.",
      "testStrategy": "Test navigation and functionality within 'Analysis & Dependencies', 'Help & Information', and 'Settings' menus. Verify that settings changes are reflected in `.taskmasterconfig`. Check for contextual information and suggestions where implemented.",
      "priority": "medium",
      "dependencies": [
        4
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement 'Analysis & Dependencies' Menu Structure and Basic Actions",
          "description": "Create the 'Analysis & Dependencies' top-level menu and its sub-items: 'Analyze Complexity', 'Complexity Report', 'Add Dependency', 'Remove Dependency', 'Validate Dependencies', and 'Fix Dependencies'. For this subtask, focus on the menu structure and placeholder actions that can be triggered (e.g., logging a message when an item is clicked), without implementing the full backend logic for each action.",
          "dependencies": [],
          "details": "Utilize the existing menu framework. Each menu item should have a basic event handler that, for now, simply logs the action to the console or displays a simple 'Not yet implemented' message. Ensure proper menu hierarchy and naming.",
          "status": "done",
          "testStrategy": "Verify that the 'Analysis & Dependencies' menu appears correctly in the UI and that all its sub-items are present and clickable. Check console logs for placeholder action triggers.",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Implement 'Help & Information' Menu Structure and Basic Actions",
          "description": "Create the 'Help & Information' top-level menu and its sub-items: 'Command Reference', 'Quick Start Guide', and 'Keyboard Shortcuts'. Similar to the Analysis menu, focus on the menu structure and placeholder actions.",
          "dependencies": [
            1
          ],
          "details": "Integrate these menu items into the UI. For 'Command Reference' and 'Quick Start Guide', consider opening a simple modal or a new tab with placeholder content. For 'Keyboard Shortcuts', a simple display of common shortcuts (even if hardcoded for now) would suffice. Ensure proper menu hierarchy and naming.",
          "status": "done",
          "testStrategy": "Verify that the 'Help & Information' menu appears correctly and all its sub-items are present and clickable. Check that placeholder content or modals appear as expected.",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Implement 'Settings' Menu Structure and `.taskmasterconfig` Integration",
          "description": "Create the 'Settings' top-level menu and its sub-items: 'Toggle Research Mode', 'Set Default File Paths', and 'Debug Mode'. Implement the initial integration with `.taskmasterconfig` for reading and displaying current settings, and for saving basic changes (e.g., toggling a boolean setting).",
          "dependencies": [
            2
          ],
          "details": "The 'Settings' menu items should reflect the current state read from `.taskmasterconfig`. 'Toggle Research Mode' and 'Debug Mode' should be checkboxes or toggle switches that update the config file upon change. 'Set Default File Paths' can initially be a text input that reads/writes a path string. Implement robust error handling for config file operations.",
          "status": "done",
          "testStrategy": "Verify the 'Settings' menu appears correctly. Test toggling 'Research Mode' and 'Debug Mode' to ensure they read from and write to `.taskmasterconfig` correctly. Verify 'Set Default File Paths' can display and update a path. Check for error messages on invalid config operations.",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Implement Contextual Help and Suggestions Framework",
          "description": "Develop a basic framework for providing contextual help and suggestions. This involves identifying key UI elements or states where help might be beneficial and implementing a mechanism to display relevant information (e.g., tooltips, status bar messages, or small pop-ups).",
          "dependencies": [
            3
          ],
          "details": "Identify at least 2-3 specific UI elements (e.g., a specific input field, a button, or a menu item) where contextual help would be useful. Implement a mechanism (e.g., on-hover tooltips, a dedicated help panel that updates based on focus, or status bar messages) to display pre-defined help text. This framework should be extensible for future additions.",
          "status": "done",
          "testStrategy": "Verify that contextual help appears for the selected UI elements. Test different interaction methods (e.g., hovering, focusing) to ensure the help text is displayed correctly and is relevant to the context.",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Refine Menu Interactions and Integrate Placeholder Functionality",
          "description": "Review all implemented menus ('Analysis', 'Help', 'Settings') and refine their interactions. For 'Analysis' and 'Help' menus, replace simple console logs with more user-friendly placeholder actions (e.g., opening a simple modal with 'Feature coming soon' or a static help document). Ensure all menu items are responsive and provide basic user feedback.",
          "dependencies": [
            4
          ],
          "details": "For 'Analysis' menu items, instead of just logging, open a small modal indicating the feature is under development. For 'Help' menu items, open a simple static HTML page or a modal with the relevant (even if minimal) content. Ensure consistent styling and responsiveness across all menus. Add basic visual feedback on click (e.g., button press state).",
          "status": "done",
          "testStrategy": "Verify that all menu items across 'Analysis', 'Help', and 'Settings' are fully functional in terms of UI interaction. Check that placeholder modals or content appear as expected for 'Analysis' and 'Help' items. Ensure consistent user experience and responsiveness.",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 6,
      "title": "Implement Robust Error Handling and Input Validation",
      "description": "Implement robust error handling mechanisms for user input validation and command execution failures, ensuring graceful recovery and clear feedback to the user.",
      "details": "Integrate input validation for all menu selections and command parameters using `inquirer.js` validation features. Provide clear, actionable error messages for invalid input. Implement `try-catch` blocks or similar mechanisms around command executions to gracefully handle failures. Ensure that after an error, the user is returned to the relevant menu with options for recovery. Log errors for debugging purposes.",
      "testStrategy": "Intentionally provide invalid input at various menu prompts and command parameter prompts, verifying correct error messages and graceful recovery. Simulate command failures and ensure the menu system handles them without crashing, returning to the menu as expected.",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Integrate Inquirer.js Input Validation for Menu Selections",
          "description": "Implement robust input validation for all menu selections using Inquirer.js's built-in validation features. This includes ensuring that user input for menu choices corresponds to valid options.",
          "dependencies": [],
          "details": "For each Inquirer.js prompt used for menu selections (e.g., list, rawlist, expand), add a `validate` function. This function should check if the user's input is one of the expected options. Provide clear, user-friendly error messages for invalid selections. Consider using a helper function to centralize common validation logic.",
          "status": "done",
          "testStrategy": "Manually test each menu by entering invalid options (e.g., non-numeric, out-of-range numbers, text) and verifying that the correct error message is displayed and the prompt re-appears until valid input is provided.",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Implement Inquirer.js Input Validation for Command Parameters",
          "description": "Extend input validation to all command parameters that require user input. This involves validating data types, formats, and constraints for parameters like file paths, names, or numerical values.",
          "dependencies": [
            1
          ],
          "details": "For each Inquirer.js prompt used to gather command parameters (e.g., input, number), add a `validate` function. This function should enforce specific rules such as non-emptiness, correct data type (e.g., numeric, string), specific format (e.g., valid file path pattern), or range constraints. Provide specific, actionable error messages for each validation failure.",
          "status": "done",
          "testStrategy": "For each command requiring parameters, test with various invalid inputs: empty strings, incorrect data types (e.g., text for a number field), out-of-range values, and malformed inputs (e.g., invalid file paths). Verify that appropriate error messages are shown and the prompt re-appears.",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Implement Centralized Error Logging Mechanism",
          "description": "Create a centralized mechanism for logging errors that occur during command execution or input processing. This log should be useful for debugging and post-mortem analysis.",
          "dependencies": [
            2
          ],
          "details": "Implement a simple logging utility (e.g., using `console.error` or a dedicated logging library like Winston/Pino if scope allows) that can record error details such as timestamp, error type, stack trace, and relevant context (e.g., command executed, input provided). Ensure logs are written to a file or displayed prominently in the console for development. Define a standard error object or structure.",
          "status": "done",
          "testStrategy": "Trigger known errors (e.g., intentionally cause a file not found error, or a parsing error) and verify that the error details are correctly logged to the console or a designated log file. Check for completeness of logged information.",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Integrate Try-Catch for Command Execution and Graceful Recovery",
          "description": "Wrap all critical command execution logic within `try-catch` blocks or similar error handling constructs to gracefully manage runtime exceptions and failures.",
          "dependencies": [
            3
          ],
          "details": "Identify all points where external commands are executed or potentially failing operations occur (e.g., file system operations, external API calls). Enclose these operations in `try-catch` blocks. Within the `catch` block, log the error using the mechanism from subtask 3, provide a user-friendly error message to the console, and ensure the application returns to the relevant menu or a stable state, rather than crashing.",
          "status": "done",
          "testStrategy": "Simulate various command execution failures (e.g., attempt to delete a non-existent file, write to a read-only directory, or trigger an internal logic error). Verify that the application does not crash, an appropriate error message is displayed to the user, the error is logged, and the user is returned to the main menu or the previous stable state.",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Refine User Feedback and Recovery Flow",
          "description": "Ensure that after any error (input validation or command execution), the user receives clear, actionable feedback and is gracefully returned to a relevant menu or prompt for recovery.",
          "dependencies": [
            4
          ],
          "details": "Review all error paths. For input validation errors, ensure the prompt re-appears with the error message. For command execution errors, after displaying the error message and logging, ensure the control flow returns to the main menu or the specific sub-menu from which the command was initiated, allowing the user to choose another action or retry. Avoid infinite loops or dead ends.",
          "status": "done",
          "testStrategy": "Perform end-to-end tests for various error scenarios. After an error, confirm that the user is always presented with clear options to proceed (e.g., return to main menu, retry input). Verify that the application state is consistent and not corrupted after an error.",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 7,
      "title": "Implement Session Management and Context Awareness",
      "description": "Implement session management to maintain menu state, user preferences, and display relevant project information and status indicators in the menu header.",
      "details": "Maintain the current menu path (breadcrumb navigation) throughout the session. Implement logic to display current project information (e.g., 'Project: taskmaster-ai'), task counts ('Tasks: 15 total (3 pending)'), and system status ('Status: ✓ Configured') in the menu header. This will require integrating with the existing project and task management core functionalities to retrieve real-time data. Consider how to remember user preferences for future enhancements.",
      "testStrategy": "Verify that breadcrumb navigation accurately reflects the current menu location. Check that project name, task counts, and status indicators in the header update dynamically and accurately based on the project's state. Test navigating through multiple levels and returning to ensure state is maintained.",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Define Session State Structure and Persistence",
          "description": "Design and implement the data structure for storing session-specific information, including current menu path (breadcrumbs) and placeholders for user preferences. Establish a mechanism for persisting this state across user interactions within a session.",
          "dependencies": [],
          "details": "Create a `SessionState` object or similar structure. For initial implementation, use in-memory storage (e.g., a singleton or application-scoped bean) for simplicity. Consider how this state will be accessed and updated by different parts of the application. Define clear getters and setters for menu path and preference placeholders.",
          "status": "done",
          "testStrategy": "Unit tests to verify `SessionState` object creation, data storage, and retrieval. Integration tests to ensure the state persists across multiple simulated user actions within a single session.",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Implement Menu Path (Breadcrumb) Management",
          "description": "Develop the logic to capture and update the current menu path (breadcrumb navigation) within the defined session state as the user navigates through the application's menu structure.",
          "dependencies": [
            1
          ],
          "details": "Modify menu navigation handlers to push/pop menu items onto/from a stack or list within the `SessionState` object. Ensure the breadcrumb accurately reflects the user's current location. Consider how to handle direct URL access to specific pages (e.g., reset breadcrumbs or reconstruct them based on URL).",
          "status": "done",
          "testStrategy": "Manual testing by navigating through various menu paths and verifying the breadcrumb display. Automated UI tests to simulate navigation and assert the correctness of the displayed breadcrumbs.",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Integrate Project and Task Data Retrieval",
          "description": "Implement the necessary service calls or data access logic to retrieve real-time project information (name) and task counts (total, pending) from the existing project and task management core functionalities.",
          "dependencies": [
            1
          ],
          "details": "Identify or create specific API endpoints/methods within the project and task management modules that can provide: 1) The currently active project's name. 2) The total count of tasks associated with the active project. 3) The count of pending tasks for the active project. Ensure these calls are efficient and handle cases where no project is active or no tasks exist.",
          "status": "done",
          "testStrategy": "Unit tests for the data retrieval methods, mocking the underlying data sources. Integration tests to ensure correct data is fetched from the actual project/task services.",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Develop Menu Header Display Logic",
          "description": "Implement the front-end logic to dynamically display the current project information, task counts, and a static system status ('Status: ✓ Configured') in the menu header, utilizing the data retrieved in previous steps.",
          "dependencies": [
            2,
            3
          ],
          "details": "Modify the menu header template or component to include placeholders for 'Project: [name]', 'Tasks: [total] total ([pending] pending)', and 'Status: ✓ Configured'. Bind these placeholders to the data retrieved from the session state (for breadcrumbs) and the project/task data retrieval logic. Ensure the header updates reactively to changes in the underlying data.",
          "status": "done",
          "testStrategy": "Manual UI testing to verify correct display of all header elements under various scenarios (e.g., project active, no project, tasks present, no tasks). Visual regression tests if applicable.",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Refine Session State and Prepare for Preferences",
          "description": "Review the session state implementation for robustness and extensibility. Add a placeholder for user preferences within the session state, even if the preference management logic isn't fully implemented yet, to prepare for future enhancements.",
          "dependencies": [
            4
          ],
          "details": "Refactor the `SessionState` object if necessary to ensure it's well-structured and easily extendable. Add a dedicated field (e.g., a map or a nested object) within `SessionState` to hold user preferences. Document the intended use of this field for future preference management features. Ensure the current session management is stable and handles edge cases gracefully.",
          "status": "done",
          "testStrategy": "Code review of the `SessionState` structure. Unit tests to confirm the presence and accessibility of the new preference placeholder. End-to-end testing to ensure the entire session management and header display remains stable after refinements.",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 8,
      "title": "Optimize Performance and Responsiveness",
      "description": "Optimize menu rendering and command execution performance to meet the specified non-functional requirements, ensuring a responsive and efficient user experience.",
      "details": "Profile menu rendering time and command execution time. Implement optimizations such as lazy loading for menu options or command details that are not immediately needed. Minimize unnecessary re-renders of the menu. Ensure that memory usage remains within acceptable limits (< 50MB additional overhead) and startup time is fast (< 500ms).",
      "testStrategy": "Measure menu rendering time using profiling tools. Execute various commands through the menu and measure their execution times, comparing them to direct CLI execution. Monitor memory usage during menu operation. Verify startup time of the menu system.",
      "priority": "medium",
      "dependencies": [
        5,
        7
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Establish Performance Baselines and Monitoring",
          "description": "Before implementing optimizations, establish clear performance baselines for menu rendering time, command execution time, memory usage, and startup time. Implement robust monitoring tools to track these metrics.",
          "dependencies": [],
          "details": "Use browser developer tools (e.g., Chrome DevTools Performance tab) for profiling rendering and execution times. For memory, use the Memory tab. For startup time, measure the time from application launch to full interactivity. Integrate a simple logging mechanism or a dedicated performance monitoring library if available to capture these metrics programmatically.",
          "status": "done",
          "testStrategy": "Run automated scripts to launch the application, navigate through menus, execute common commands, and record the specified metrics. Compare against initial non-functional requirements (e.g., startup < 500ms, memory < 50MB additional).",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Implement Lazy Loading for Menu Options and Command Details",
          "description": "Optimize menu rendering by implementing lazy loading for menu options or command details that are not immediately visible or required upon initial menu display.",
          "dependencies": [
            1
          ],
          "details": "Identify parts of the menu structure or command details that can be loaded asynchronously. For example, if a submenu has many items, only load the first few and fetch more as the user scrolls or hovers. For command details, load comprehensive descriptions or complex parameters only when a command is selected or about to be executed. Use techniques like React.lazy() and Suspense if applicable, or custom component-level lazy loading logic.",
          "status": "done",
          "testStrategy": "Verify that initial menu load times are reduced. Observe network requests to confirm that lazy-loaded content is fetched only when needed. Test user experience to ensure no noticeable lag when content is loaded on demand.",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Optimize Menu Re-rendering and Component Updates",
          "description": "Minimize unnecessary re-renders of the menu components to improve responsiveness and reduce CPU cycles.",
          "dependencies": [
            1,
            2
          ],
          "details": "Analyze component re-renders using profiling tools (e.g., React DevTools Profiler). Implement memoization techniques (e.g., React.memo, useCallback, useMemo) for functional components and PureComponent/shouldComponentUpdate for class components. Ensure that state updates are granular and only trigger re-renders for affected components. Avoid passing new object/array references as props unnecessarily.",
          "status": "done",
          "testStrategy": "Use profiling tools to confirm a significant reduction in re-renders for menu components when unrelated state changes occur. Verify that menu interactions remain smooth and responsive.",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Refactor Command Execution Logic for Efficiency",
          "description": "Optimize the execution path of commands to ensure they run efficiently and do not block the UI thread.",
          "dependencies": [
            1,
            3
          ],
          "details": "Identify computationally intensive parts of command execution. If possible, offload heavy computations to web workers or process them asynchronously. Minimize synchronous operations that could block the main thread. Review data structures and algorithms used in command processing for efficiency. Cache results of frequently executed commands or expensive computations where appropriate.",
          "status": "done",
          "testStrategy": "Measure command execution times for various commands, especially complex ones, to ensure they meet performance targets. Verify that the UI remains responsive during command execution, without freezing or noticeable delays.",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Conduct Comprehensive Performance Regression Testing and Reporting",
          "description": "After implementing optimizations, conduct thorough regression testing to ensure performance improvements are sustained and no new bottlenecks are introduced. Generate a final performance report.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Re-run all performance baseline tests established in Subtask 1. Compare current metrics against baselines and target non-functional requirements. Document all findings, including improvements, any regressions, and remaining areas for optimization. Ensure memory usage is within limits and startup time is fast. Provide a summary report with recommendations for future performance monitoring.",
          "status": "done",
          "testStrategy": "Automated performance tests covering all key metrics (startup, rendering, execution, memory). Manual verification of user experience responsiveness. Generate a final report detailing compliance with NFRs and comparing 'before' and 'after' metrics.",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 9,
      "title": "Comprehensive Testing and Quality Assurance",
      "description": "Conduct comprehensive testing of all menu paths, command integrations, error handling, and performance to ensure stability, usability, and adherence to all requirements.",
      "details": "Perform end-to-end testing of all menu navigation paths, including main menu, sub-menus, back, and exit options. Test every command integration, ensuring correct parameter handling, output display, and return to menu. Thoroughly test all error handling scenarios. Verify backward compatibility with existing commands. Conduct cross-platform compatibility testing on major terminal applications. Document any identified bugs and ensure they are addressed.",
      "testStrategy": "Execute a comprehensive test suite covering all functional and non-functional requirements. Use a combination of manual and automated tests. Track test coverage and defect rates. Verify all acceptance criteria are met.",
      "priority": "high",
      "dependencies": [
        8
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Develop Comprehensive Test Plan and Test Cases",
          "description": "Create a detailed test plan outlining the scope, objectives, resources, and schedule for comprehensive testing. Develop specific test cases for all menu navigation paths, command integrations, error handling scenarios, and cross-platform compatibility. Prioritize test cases based on criticality and frequency of use.",
          "dependencies": [],
          "details": "The test plan should cover functional, integration, error handling, and compatibility testing. Test cases should include preconditions, steps, expected results, and post-conditions. Utilize a test management tool if available to organize and track test cases.",
          "status": "done",
          "testStrategy": "Review test plan and test cases with development and product teams to ensure coverage and accuracy before execution.",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Execute Functional and Navigation Testing",
          "description": "Execute all test cases related to menu navigation (main menu, sub-menus, back, exit options) and core command functionalities. Verify correct display, input handling, and transitions between different parts of the application.",
          "dependencies": [
            1
          ],
          "details": "Systematically go through each menu path and command, ensuring that all options are accessible and function as expected. Document any deviations from expected behavior as bugs. Pay close attention to edge cases in navigation.",
          "status": "done",
          "testStrategy": "Perform manual execution of all functional and navigation test cases. Log defects with clear steps to reproduce, actual results, and expected results.",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Execute Command Integration and Error Handling Testing",
          "description": "Thoroughly test all command integrations, ensuring correct parameter handling, output display, and proper return to the main menu or previous state. Conduct extensive error handling testing, including invalid inputs, missing parameters, and system errors, to ensure graceful degradation and informative error messages.",
          "dependencies": [
            2
          ],
          "details": "For command integration, test with valid, invalid, and boundary parameters. Verify that outputs are correctly formatted and displayed. For error handling, simulate various error conditions (e.g., network issues, file not found, permission denied) and confirm that the application handles them robustly without crashing, providing user-friendly feedback.",
          "status": "done",
          "testStrategy": "Automate command integration tests where possible. Manually test a wide range of error scenarios, focusing on user experience and system stability under duress.",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Perform Cross-Platform Compatibility and Backward Compatibility Testing",
          "description": "Test the application's compatibility across major terminal applications (e.g., Bash, Zsh, PowerShell, CMD) and operating systems (if applicable). Verify backward compatibility with existing commands and configurations to ensure seamless upgrades for existing users.",
          "dependencies": [
            3
          ],
          "details": "Set up test environments for each target terminal and OS. Execute a subset of critical functional and integration test cases on each platform. For backward compatibility, test the new version with configurations and data generated by previous versions of the application.",
          "status": "done",
          "testStrategy": "Manual testing on different terminal emulators and OS environments. Use a matrix to track compatibility results. Ensure that old commands still function as expected in the new environment.",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Performance Testing and Bug Resolution Tracking",
          "description": "Conduct basic performance tests to identify any significant bottlenecks or slowdowns during typical usage. Document all identified bugs, prioritize them, and track their resolution through to retesting and closure. Generate a final test report summarizing findings.",
          "dependencies": [
            4
          ],
          "details": "Monitor resource usage (CPU, memory) during heavy command execution or long sessions. Use a bug tracking system to log, assign, and manage defects. Ensure all critical and major bugs are resolved and retested before final sign-off. The test report should include test coverage, executed test cases, defects found, and overall quality assessment.",
          "status": "done",
          "testStrategy": "Use system monitoring tools for performance checks. Implement a clear bug lifecycle in the tracking system. Conduct regression testing after bug fixes to ensure no new issues are introduced.",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 10,
      "title": "Update User Documentation",
      "description": "Update documentation to include instructions for using the new interactive menu system, including entry points, navigation, and key features.",
      "details": "Create or update relevant sections in the TaskHero AI documentation to explain how to launch and navigate the interactive menu. Include examples of common workflows, keyboard shortcuts, and any new features introduced by the menu system. Ensure the documentation is clear, concise, and easy to understand for new and experienced users.",
      "testStrategy": "Review the updated documentation for accuracy, completeness, and clarity. Have a new user attempt to use the menu system solely based on the documentation to assess its effectiveness.",
      "priority": "low",
      "dependencies": [
        9
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Identify and Outline Documentation Sections",
          "description": "Review existing documentation to identify relevant sections for updates and propose new sections if necessary. Create a detailed outline for the interactive menu system documentation, covering entry points, navigation, and key features.",
          "dependencies": [],
          "details": "Access the current TaskHero AI documentation. Map out where the new interactive menu system information best fits. Consider creating a dedicated 'Interactive Menu System' section or integrating into existing 'Getting Started' or 'User Interface' sections. Outline sub-sections for 'Launching the Menu', 'Navigating Options', 'Common Workflows', and 'Key Features'.",
          "status": "done",
          "testStrategy": "Review the proposed outline with a product owner or subject matter expert to ensure all critical aspects are covered and logically organized.",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Draft Entry Points and Basic Navigation Instructions",
          "description": "Write the initial draft for how users can access the interactive menu system and perform basic navigation. Include clear steps, screenshots (if applicable), and keyboard shortcuts.",
          "dependencies": [
            1
          ],
          "details": "Based on the outline from subtask 1, focus on the 'Launching the Menu' and 'Navigating Options' sections. Describe all methods to open the menu (e.g., hotkey, command line). Detail how to move between options (e.g., arrow keys, mouse clicks) and select items. Include specific keyboard shortcuts for common actions.",
          "status": "done",
          "testStrategy": "Perform a walkthrough of the drafted instructions using the actual interactive menu system to verify accuracy and clarity. Ensure all steps are reproducible.",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Document Key Features and Common Workflows",
          "description": "Draft the documentation for the core functionalities and common use cases of the interactive menu system. Provide examples of how users can achieve specific tasks using the menu.",
          "dependencies": [
            2
          ],
          "details": "Expand on the 'Key Features' and 'Common Workflows' sections. Describe the purpose and usage of each significant feature accessible via the menu. Provide step-by-step examples for typical user scenarios (e.g., 'How to create a new task using the menu', 'How to filter tasks'). Use clear, concise language and avoid jargon where possible.",
          "status": "done",
          "testStrategy": "Test each documented workflow and feature example against the live interactive menu system to confirm accuracy and completeness. Solicit feedback from a new user to assess clarity.",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Review, Refine, and Add Visuals",
          "description": "Conduct a comprehensive review of all drafted content for clarity, conciseness, accuracy, and consistency. Integrate relevant screenshots or diagrams to enhance understanding.",
          "dependencies": [
            3
          ],
          "details": "Proofread the entire document for grammatical errors, typos, and awkward phrasing. Ensure consistent terminology and formatting. Capture high-quality screenshots of the interactive menu at various stages (e.g., open menu, selected option, confirmation dialog) and embed them appropriately. Add alt text to all images.",
          "status": "done",
          "testStrategy": "Perform a final read-through focusing on user experience. Check that all images are correctly placed and enhance the text. Have a peer review the entire document for any missed errors or areas of confusion.",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Publish and Announce Documentation Updates",
          "description": "Integrate the finalized documentation into the official TaskHero AI documentation platform and communicate the updates to relevant stakeholders and users.",
          "dependencies": [
            4
          ],
          "details": "Upload the updated documentation files to the designated documentation repository (e.g., Confluence, ReadTheDocs, internal wiki). Ensure proper linking and navigation within the documentation portal. Draft an announcement (e.g., email, release notes, internal chat message) highlighting the new documentation and its benefits for users.",
          "status": "done",
          "testStrategy": "Verify that the published documentation is accessible, searchable, and correctly rendered on the live platform. Confirm that the announcement reaches the intended audience and clearly communicates the update.",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 21,
      "title": "Enhance Task Schema with PRD Source Field",
      "description": "Enhance the existing task data structure to include a new 'prdSource' field. This field will be an object containing metadata about the PRD file from which the task was generated. This is a foundational change for all subsequent features.",
      "details": "Modify the task object schema to include the 'prdSource' field as specified in the PRD. The 'prdSource' object should contain 'filePath', 'fileName', 'parsedDate', 'fileHash', and 'fileSize'. Ensure backward compatibility for existing tasks by setting 'prdSource' to null or an empty object for tasks not yet associated with a PRD. This will likely involve updating `tasks.json` and potentially `task_xxx.txt` file formats.",
      "testStrategy": "Unit tests to verify the new schema can be parsed and serialized correctly. Integration tests to ensure existing tasks without the new field are handled gracefully without errors. Verify that new tasks created with the 'prdSource' field correctly store the data.",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Define `prdSource` Field and Sub-fields in Task Object Schema",
          "description": "Precisely define the new `prdSource` field within the task object schema, including its specified sub-fields (e.g., `type`, `url`, `id`). This involves updating the internal data structure definition.",
          "dependencies": [],
          "details": "This step involves updating the core data structure that represents a task. For example, if using a class, add a new property `prdSource` with its own nested properties. If using a JSON schema, update the schema definition accordingly. Ensure data types and constraints for each sub-field are clearly defined.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Implement Backward Compatibility for `tasks.json`",
          "description": "Develop logic to gracefully handle existing `tasks.json` files that do not contain the `prdSource` field. This includes ensuring the application can read and process these files without errors, potentially initializing `prdSource` to a default or null value.",
          "dependencies": [
            1
          ],
          "details": "When loading `tasks.json`, if `prdSource` is missing, the parsing logic should not fail. It should either assign a default empty/null object to `prdSource` or ensure that subsequent code gracefully handles its absence. This might involve conditional parsing or default value assignment during deserialization.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Implement Backward Compatibility for `task_xxx.txt`",
          "description": "Develop logic to gracefully handle existing `task_xxx.txt` files that do not contain the `prdSource` field. This involves updating the parsing mechanism for these files to avoid errors and ensure existing data remains accessible.",
          "dependencies": [
            1
          ],
          "details": "Similar to `tasks.json`, the parsing logic for `task_xxx.txt` files needs to be updated. If `prdSource` information is not present in the text file, the parser should not throw an error. It should either ignore the missing field or initialize it to a default value when constructing the task object from the text file.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Develop Unit Tests for Schema Parsing and Serialization",
          "description": "Create comprehensive unit tests to verify correct parsing of both old (without `prdSource`) and new (with `prdSource`) schema versions from `tasks.json` and `task_xxx.txt`. Also, test serialization of tasks with and without `prdSource` to ensure correct output.",
          "dependencies": [
            2,
            3
          ],
          "details": "Unit tests should cover: 1. Loading an old `tasks.json` and verifying `prdSource` is handled correctly (e.g., null/default). 2. Loading a new `tasks.json` and verifying `prdSource` is parsed correctly. 3. Loading an old `task_xxx.txt` and verifying `prdSource` is handled correctly. 4. Loading a new `task_xxx.txt` and verifying `prdSource` is parsed correctly. 5. Serializing a task without `prdSource` and verifying the output. 6. Serializing a task with `prdSource` and verifying the output.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Develop Integration Tests for Graceful Handling of Existing Data",
          "description": "Create integration tests to simulate real-world scenarios, including loading a mix of old and new task data, performing operations (e.g., editing, saving), and verifying data integrity and application stability.",
          "dependencies": [
            4
          ],
          "details": "Integration tests should simulate: 1. Starting the application with an existing `tasks.json` (old format) and `task_xxx.txt` files (old format). 2. Modifying an existing task (which might not have `prdSource`) and saving it. 3. Creating a new task with `prdSource` and saving it. 4. Verifying that all tasks (old and new) are displayed correctly and that no data corruption occurs. 5. Testing edge cases like malformed `prdSource` data if applicable.",
          "status": "done",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 22,
      "title": "Integrate PRD Metadata Capture into Parse Command",
      "description": "Modify the `parse-prd` command to capture and store PRD metadata (file path, name, parsed date, hash, size) into the new 'prdSource' field of generated tasks. This is crucial for establishing the traceability link.",
      "details": "Update the `parse-prd` command in `scripts/modules/commands.js` to extract the file path, file name, current timestamp for `parsedDate`, calculate `fileHash` (e.g., SHA256), and `fileSize` during PRD parsing. This information should then be populated into the `prdSource` field of each task generated from that PRD. Handle both relative and absolute file paths consistently. Consider using a hashing library for `fileHash` calculation.",
      "testStrategy": "Unit tests for the `parse-prd` command to ensure all `prdSource` fields are correctly populated for newly generated tasks. End-to-end tests to verify that tasks created via `parse-prd` have accurate PRD source information stored in their respective JSON and text files.",
      "priority": "high",
      "dependencies": [
        21
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Analyze existing `parse-prd` command and identify modification points",
          "description": "Review `scripts/modules/commands.js` to understand the current `parse-prd` command's logic, data extraction methods, and where `prdSource` fields can be integrated. Identify the specific areas requiring modification for new data extraction.",
          "dependencies": [],
          "details": "Examine the `parse-prd` function, its input parameters, and how it currently processes PRD files. Pinpoint the exact location where `prdSource` data should be extracted and populated within the command's output structure.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Implement `prdSource` field extraction and population",
          "description": "Modify the `parse-prd` command to extract all necessary `prdSource` fields from the PRD files. Populate these fields into the appropriate data structure generated by the command.",
          "dependencies": [
            1
          ],
          "details": "Define the structure for `prdSource` fields (e.g., `sourcePath`, `fileHash`, `lastModified`). Implement logic to read these values from the PRD file's metadata or content and assign them to the `prdSource` object.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Develop `fileHash` calculation logic",
          "description": "Implement a robust method within the `parse-prd` command to calculate the `fileHash` for each PRD file. This should ensure uniqueness and integrity of the file identification.",
          "dependencies": [
            2
          ],
          "details": "Choose an appropriate hashing algorithm (e.g., SHA256). Implement the file reading and hashing process, ensuring efficient handling of file I/O and accurate hash generation. Integrate this calculation into the `prdSource` population.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Handle file paths for `prdSource`",
          "description": "Ensure correct and consistent handling of file paths for `prdSource` fields, including absolute vs. relative paths, and cross-platform compatibility.",
          "dependencies": [
            2
          ],
          "details": "Determine whether to store absolute or relative paths for `sourcePath`. Implement logic to normalize paths and ensure they are correctly resolved regardless of the operating system or execution environment.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Write unit tests for `prdSource` field population",
          "description": "Create comprehensive unit tests to verify that all `prdSource` fields are correctly extracted and populated by the `parse-prd` command.",
          "dependencies": [
            4
          ],
          "details": "Develop test cases that cover various PRD file structures, including cases with missing or malformed `prdSource` data. Assert that `sourcePath`, `fileHash`, and other `prdSource` fields are populated accurately.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 6,
          "title": "Write unit tests for `fileHash` calculation",
          "description": "Develop specific unit tests to validate the accuracy and consistency of the `fileHash` calculation logic.",
          "dependencies": [
            3
          ],
          "details": "Create test files with known content and pre-calculated hashes. Verify that the implemented `fileHash` function produces the expected hash values for these files. Test edge cases like empty files or very large files.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 7,
          "title": "Develop end-to-end tests for accurate storage in task files",
          "description": "Implement end-to-end tests to ensure that the `prdSource` information, including `fileHash` and paths, is accurately stored in the generated task files after running the `parse-prd` command.",
          "dependencies": [
            5,
            6
          ],
          "details": "Set up a test environment, run the `parse-prd` command on sample PRD files, and then inspect the generated task files to confirm that the `prdSource` object and its fields are correctly persisted.",
          "status": "done",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 23,
      "title": "Display PRD Source in Task Views and Reports",
      "description": "Update all relevant UI components (task list, task details, project dashboard, interactive menu) to display the PRD source information for each task. This provides immediate visual traceability to users.",
      "details": "Modify `scripts/modules/ui.js` and other display functions to show the `prdSource.fileName` in the task list view (e.g., as a new column). Enhance the individual task details view to display all `prdSource` fields (filePath, parsedDate, version, etc.). Update the project dashboard to include a summary of PRD sources (e.g., number of PRD files processed, total tasks generated per PRD). Ensure interactive menu displays also reflect this information.",
      "testStrategy": "Manual UI testing to confirm PRD source information is correctly displayed across all specified views (task list, task details, dashboard, interactive menu). Automated screenshot comparisons or UI element checks could be implemented for regression testing.",
      "priority": "medium",
      "dependencies": [
        22
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Identify UI Components for Modification",
          "description": "List all specific UI components that will be affected by the integration of `prdSource` information, based on the provided context.",
          "dependencies": [],
          "details": "The prompt explicitly mentions 'task list, task details, project dashboard, interactive menu'. These should be confirmed as the target components.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Detail Changes for Task List and Task Details Views",
          "description": "Specify the exact modifications required for the 'task list' and 'task details' UI components to display `prdSource` information. This includes layout, formatting, and data presentation.",
          "dependencies": [
            1
          ],
          "details": "For each view, consider where `prdSource` will be displayed, its label, and how it will be formatted (e.g., as a link, text, etc.).",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Detail Changes for Project Dashboard and Interactive Menu Views",
          "description": "Specify the exact modifications required for the 'project dashboard' and 'interactive menu' UI components to display `prdSource` information. This includes layout, formatting, and data presentation.",
          "dependencies": [
            1
          ],
          "details": "Similar to subtask 2, define how `prdSource` will be integrated into these views, considering their specific layouts and functionalities.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Outline Manual UI Testing Plan",
          "description": "Develop a comprehensive plan for manually testing the UI changes across all modified components to ensure correct display and functionality of `prdSource` information.",
          "dependencies": [
            2,
            3
          ],
          "details": "The plan should include test cases for each modified view, covering different scenarios (e.g., `prdSource` present, `prdSource` absent, different `prdSource` formats).",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Consider Automated UI Element Checks for Regression",
          "description": "Investigate and propose strategies for implementing automated UI element checks to prevent regression issues related to the `prdSource` display.",
          "dependencies": [
            2,
            3
          ],
          "details": "This could involve using existing UI testing frameworks (e.g., Selenium, Cypress) to verify the presence, position, and content of the `prdSource` element after changes.",
          "status": "done",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 24,
      "title": "Implement PRD Source Query and Filter Commands",
      "description": "Implement new commands to query and filter tasks based on their PRD source. This includes listing all PRDs, showing tasks from a specific PRD, and displaying the PRD source for a given task ID.",
      "details": "Add new commands to the command registry (e.g., `task-master list-prds`, `task-master tasks-from-prd --file=<path>`, `task-master show-prd-source --id=<id>`). `list-prds` should iterate through all tasks and unique `prdSource.filePath` values. `tasks-from-prd` should filter tasks based on the provided PRD file path. `show-prd-source` should retrieve and display the `prdSource` object for a specific task ID. Implement efficient data retrieval for these queries.",
      "testStrategy": "Unit tests for each new command to verify correct filtering and data retrieval logic. Integration tests to ensure commands interact correctly with the task data store and return accurate results based on the PRD source information.",
      "priority": "medium",
      "dependencies": [
        21
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Define `list-prds` command",
          "description": "Specify the command name, arguments (e.g., filters like status, owner), and expected output format for listing product requirements documents (PRDs).",
          "dependencies": [],
          "details": "This command should allow users to view a summary of all PRDs, potentially filtered by their current status (e.g., 'draft', 'approved', 'in-progress') or assigned owner. The output should be concise, showing key identifiers and a brief description.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Define `tasks-from-prd` command",
          "description": "Specify the command name, arguments (e.g., PRD ID), and expected output format for extracting tasks associated with a specific PRD.",
          "dependencies": [
            1
          ],
          "details": "This command will take a PRD identifier as input and display all tasks that are linked to that PRD. The output should include task ID, description, and current status. Consider options for filtering tasks (e.g., by status).",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Define `show-prd-source` command",
          "description": "Specify the command name, arguments (e.g., PRD ID), and expected output format for displaying the raw source content of a PRD.",
          "dependencies": [
            1
          ],
          "details": "This command will retrieve and display the complete, raw content of a specified PRD. This is useful for debugging or reviewing the full document as it exists in the data store.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Implement data retrieval and filtering logic",
          "description": "Develop the backend logic for efficiently retrieving PRD and task data, including filtering capabilities based on command arguments.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Focus on optimizing queries for performance, especially when dealing with large datasets. Implement indexing strategies if applicable. Ensure robust error handling for invalid inputs or missing data.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Implement command handlers",
          "description": "Develop the command handlers that parse arguments, call the data retrieval logic, and format the output for each new command.",
          "dependencies": [
            4
          ],
          "details": "Each command handler (`list-prds`, `tasks-from-prd`, `show-prd-source`) will be responsible for interpreting user input, invoking the appropriate data access methods, and presenting the results in a user-friendly format.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 6,
          "title": "Develop unit tests for command logic",
          "description": "Write unit tests to verify the correctness of argument parsing, filtering logic, and output formatting for each command.",
          "dependencies": [
            5
          ],
          "details": "These tests should isolate the command logic from the actual data store, using mock data where necessary. Cover various scenarios, including valid inputs, invalid inputs, and edge cases.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 7,
          "title": "Develop integration tests for data store interaction",
          "description": "Write integration tests to ensure the commands correctly interact with the data store and produce accurate results.",
          "dependencies": [
            5,
            6
          ],
          "details": "These tests will involve a real or simulated data store to verify that data retrieval, filtering, and display work as expected end-to-end. Test data should be set up to cover different scenarios (e.g., PRDs with no tasks, PRDs with many tasks, filtered results).",
          "status": "done",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 25,
      "title": "Implement PRD Change Detection and Flagging",
      "description": "Develop functionality to detect modifications in source PRD files and flag associated tasks as outdated. This is a critical step for change management and ensuring task relevance.",
      "details": "Create a mechanism (e.g., a new command `task-master check-prd-updates` or an automated background process) that compares the current `fileHash` and `fileSize` of the PRD file on disk with the stored `prdSource.fileHash` and `prdSource.fileSize` for each task. If a discrepancy is found, flag the associated tasks (e.g., by adding a new 'outdated' status or a specific flag in the task object). Consider using file system watchers for real-time detection if feasible, otherwise, a periodic check.",
      "testStrategy": "Unit tests for the change detection logic, simulating file modifications and verifying that tasks are correctly flagged. End-to-end tests to confirm that running `check-prd-updates` accurately identifies and flags tasks linked to modified PRD files.",
      "priority": "medium",
      "dependencies": [
        21
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Choose PRD File Monitoring Mechanism",
          "description": "Evaluate and select the most suitable mechanism for detecting PRD file modifications (e.g., OS-level file watchers, polling with checksums, background process). Consider real-time vs. periodic checks.",
          "dependencies": [],
          "details": "Research `inotify` (Linux), `FSEvents` (macOS), `ReadDirectoryChangesW` (Windows) for real-time, or define a polling interval for periodic checks. Document pros and cons of each.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Implement File Hash Calculation",
          "description": "Develop a utility function to calculate a cryptographic hash (e.g., SHA256) of a given PRD file's content.",
          "dependencies": [],
          "details": "The function should take a file path as input and return a string representing the file's hash. Handle potential file I/O errors.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Implement File Size Retrieval",
          "description": "Develop a utility function to retrieve the size of a given PRD file.",
          "dependencies": [],
          "details": "The function should take a file path as input and return an integer representing the file size in bytes. Handle potential file I/O errors.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Define PRD Change Detection Logic",
          "description": "Implement the core logic for detecting PRD file modifications based on `fileHash` and `fileSize` comparison.",
          "dependencies": [
            2,
            3
          ],
          "details": "The logic should first compare `fileSize`. If different, a change is detected. If `fileSize` is the same, then compare `fileHash`. If `fileHash` is different, a change is detected. If both are the same, no change.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Integrate Monitoring Mechanism with Detection Logic",
          "description": "Connect the chosen PRD file monitoring mechanism (from subtask 1) with the change detection logic (from subtask 4).",
          "dependencies": [
            1,
            4
          ],
          "details": "If using real-time watchers, the callback should trigger the detection logic. If using polling, a scheduled job should periodically run the detection logic for all monitored PRD files.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 6,
          "title": "Define Task Outdating Mechanism",
          "description": "Design how tasks associated with a modified PRD file will be flagged as 'outdated' or 'requiring review'.",
          "dependencies": [
            5
          ],
          "details": "Specify the data model changes required to store the 'outdated' status for tasks. Consider how this status will be propagated or displayed in the UI.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 7,
          "title": "Develop Unit Tests for Change Detection",
          "description": "Write comprehensive unit tests for the file hash calculation, file size retrieval, and the core change detection logic.",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "Test cases should include: identical files, files with different content but same size, files with different size, empty files, and error handling (e.g., file not found).",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 8,
          "title": "Develop End-to-End Tests for Accurate Flagging",
          "description": "Create end-to-end tests to verify that PRD file modifications correctly lead to associated tasks being flagged as outdated.",
          "dependencies": [
            5,
            6
          ],
          "details": "Simulate PRD file changes (e.g., programmatically modify a test PRD file) and assert that the corresponding tasks in the system are correctly marked as outdated.",
          "status": "done",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 26,
      "title": "Develop PRD Re-parsing and Update Logic",
      "description": "Enable the system to re-parse updated PRD files, allowing for incremental updates to existing tasks or creation of new tasks based on the changes. This includes maintaining a history of PRD associations.",
      "details": "Implement the `task-master reparse-prd --file=<path> --update-existing` command. This command should re-read the specified PRD file. If `--update-existing` is used, it should attempt to identify and update existing tasks that originated from this PRD. This might involve comparing task titles or descriptions to detect changes. New tasks identified in the updated PRD should be created. Maintain a `prd-history.json` to track parsing sessions and changes over time.",
      "testStrategy": "Unit tests for the re-parsing logic, ensuring that existing tasks are updated correctly and new tasks are created as expected. Integration tests to verify that re-parsing a modified PRD correctly updates the task data and that the `prd-history.json` accurately reflects the parsing sessions.",
      "priority": "medium",
      "dependencies": [
        25
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Define `reparse-prd` command structure and arguments",
          "description": "Outline the command-line interface for `reparse-prd`, including the main command and the `--update-existing` flag. Specify argument parsing and basic validation.",
          "dependencies": [],
          "details": "Define `argparse` structure. Specify `--update-existing` as a boolean flag. Consider other potential flags like `--dry-run` for future expansion.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Implement PRD file reading and parsing",
          "description": "Develop the core logic to read and parse PRD files (e.g., Markdown, YAML) into an in-memory data structure representing tasks, features, etc.",
          "dependencies": [],
          "details": "Choose a parsing library (e.g., `markdown-it`, `PyYAML`). Define the internal data model for parsed PRD content. Handle potential parsing errors.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Design `prd-history.json` structure",
          "description": "Define the schema and content for `prd-history.json` to store historical versions of PRD data, including timestamps and version identifiers.",
          "dependencies": [],
          "details": "Consider storing full PRD content, diffs, or metadata. Include fields for timestamp, PRD file hash/checksum, and potentially a version number.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Implement logic for identifying existing tasks",
          "description": "Develop algorithms to compare newly parsed tasks with existing tasks (from the current state or `prd-history.json`) to identify matches based on criteria like title, description, or unique identifiers.",
          "dependencies": [
            2
          ],
          "details": "Define matching heuristics (e.g., exact title match, fuzzy title match, content hash). Prioritize unique IDs if available. Handle cases where multiple matches are found.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Implement task update logic (`--update-existing` enabled)",
          "description": "Develop the logic to update existing tasks in the system based on changes detected in the re-parsed PRD, specifically when `--update-existing` is true.",
          "dependencies": [
            4
          ],
          "details": "Determine which fields can be updated (e.g., description, status, assignee). Implement conflict resolution strategies if external changes occurred. Ensure atomicity of updates.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 6,
          "title": "Implement new task creation logic",
          "description": "Develop the logic to create new tasks in the system for items found in the re-parsed PRD that do not have a corresponding existing task.",
          "dependencies": [
            4
          ],
          "details": "Define default values for new tasks. Integrate with the task management system's API for creation. Handle potential errors during creation.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 7,
          "title": "Implement `prd-history.json` management",
          "description": "Develop the logic to read from and write to `prd-history.json`, including versioning, archiving previous states, and ensuring data integrity.",
          "dependencies": [
            3
          ],
          "details": "Implement read/write functions. Consider strategies for limiting history size (e.g., keeping N versions, or versions for X days). Use atomic writes to prevent corruption.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 8,
          "title": "Develop unit tests for re-parsing and task identification logic",
          "description": "Create comprehensive unit tests for the PRD parsing, task identification (matching), and update/creation decision-making components.",
          "dependencies": [
            2,
            4,
            5,
            6
          ],
          "details": "Test various PRD formats, edge cases (empty files, malformed content). Test different scenarios for task matching (exact, partial, no match). Test update/create decisions based on `--update-existing` flag.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 9,
          "title": "Develop integration tests for task data updates and history tracking",
          "description": "Create end-to-end integration tests to verify that `reparse-prd` correctly updates/creates tasks in the system and accurately manages `prd-history.json`.",
          "dependencies": [
            1,
            7,
            8
          ],
          "details": "Simulate PRD changes over time. Verify task updates in a mock task management system. Verify `prd-history.json` content after multiple re-parsing runs. Test `--update-existing` flag behavior end-to-end.",
          "status": "done",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 27,
      "title": "Implement PRD Traceability Reporting",
      "description": "Implement functionality to generate traceability reports, linking tasks back to their source PRDs. This is essential for audit and compliance requirements.",
      "details": "Develop the `task-master prd-traceability-report --format=csv` command. This command should generate a report (e.g., CSV, JSON) that clearly maps tasks to their originating PRD files and relevant metadata. The report should include task ID, title, PRD file path, parsed date, and potentially other relevant PRD source fields. Ensure the report format is suitable for compliance auditing.",
      "testStrategy": "Unit tests for the report generation logic, verifying that the output format is correct and contains all required data. Manual review of generated reports to ensure accuracy and completeness of traceability information.",
      "priority": "low",
      "dependencies": [
        21
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Define `prd-traceability-report` Command Structure",
          "description": "Design the command-line interface for `prd-traceability-report`, including arguments for output format (e.g., --format csv, --format json) and potential filtering options.",
          "dependencies": [],
          "details": "Specify command name, required and optional arguments, and help text. Consider using a library like `argparse`.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Identify Required Data Points for Report",
          "description": "List all necessary data points to be included in the traceability report, such as task ID, title, PRD file path, parsed date, associated requirements, and linked code changes.",
          "dependencies": [],
          "details": "Brainstorm all relevant information that would contribute to PRD traceability. Consider data available from existing parsing and linking processes.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Implement Report Generation Logic",
          "description": "Develop the core logic to gather data points identified in Subtask 2, process them, and format them according to the specified output format (CSV, JSON).",
          "dependencies": [
            1,
            2
          ],
          "details": "This involves querying the internal data structures (e.g., parsed PRD data, linked code changes) and preparing them for output. Create separate functions for CSV and JSON formatting.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Develop Unit Tests for Output Format",
          "description": "Write unit tests to verify that the `prd-traceability-report` command generates output in the correct format (CSV and JSON) based on the `--format` argument.",
          "dependencies": [
            3
          ],
          "details": "Tests should check for correct delimiters, JSON structure, header rows, and data types for each format.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Develop Unit Tests for Data Accuracy",
          "description": "Create unit tests to ensure the data points included in the report are accurate and complete, matching the expected values from the source data.",
          "dependencies": [
            3
          ],
          "details": "Tests should verify that task IDs, titles, file paths, parsed dates, and linked information are correctly extracted and presented in the report.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 6,
          "title": "Outline Manual Review Steps for Report",
          "description": "Define a set of manual review steps to validate the generated traceability report for overall correctness, readability, and completeness beyond automated tests.",
          "dependencies": [
            4,
            5
          ],
          "details": "This includes spot-checking data, verifying links, and ensuring the report meets compliance or auditing requirements. Consider scenarios like missing data or incorrect associations.",
          "status": "done",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 28,
      "title": "Establish Comprehensive Testing Strategy",
      "description": "Establish a robust testing strategy covering unit, integration, end-to-end, performance, and cross-platform compatibility for all new PRD source tracking features.",
      "details": "Develop a detailed test plan encompassing unit tests for individual components (e.g., PRD metadata extraction, hash calculation), integration tests for command interactions and data flow, end-to-end tests for complete user workflows (e.g., parse PRD -> view tasks -> re-parse PRD), performance tests with large datasets, and cross-platform compatibility tests (Windows, macOS, Linux) to address file path handling and other OS-specific nuances. Automate as many tests as possible.",
      "testStrategy": "Execution of all defined test cases. Monitoring of test coverage metrics. Documentation of test results and bug reports. Regular review of the test suite to ensure it remains comprehensive and effective as features evolve.",
      "priority": "low",
      "dependencies": [
        21,
        22,
        23,
        24,
        25,
        26,
        27
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Define Scope and Features for Testing",
          "description": "Identify all new PRD source tracking features that require testing. List specific functionalities, user flows, and data points associated with these features.",
          "dependencies": [],
          "details": "Review PRD documents, design specifications, and any existing feature breakdowns to create a definitive list of new source tracking features. This will form the basis for all subsequent testing activities.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 2,
          "title": "Develop Unit Test Plan and Scenarios",
          "description": "Outline the strategy for unit testing, including key test scenarios for individual components and functions of the new source tracking features.",
          "dependencies": [
            1
          ],
          "details": "For each identified feature, break down into smallest testable units. Define expected inputs, outputs, and edge cases. Specify mocking strategies for dependencies.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 3,
          "title": "Develop Integration Test Plan and Scenarios",
          "description": "Create a plan for integration testing, focusing on interactions between different modules and services related to source tracking.",
          "dependencies": [
            1
          ],
          "details": "Identify integration points between new source tracking features and existing systems (e.g., database, analytics, UI). Define scenarios for data flow, API calls, and error handling across integrated components.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 4,
          "title": "Develop End-to-End Test Plan and Scenarios",
          "description": "Design end-to-end test scenarios that simulate real user journeys involving the new source tracking features from start to finish.",
          "dependencies": [
            1
          ],
          "details": "Map out complete user flows involving source tracking, from initial input to final data persistence and reporting. Include positive, negative, and boundary test cases covering all user interactions.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 5,
          "title": "Develop Performance Test Plan and Scenarios",
          "description": "Outline the strategy for performance testing, including load, stress, and scalability tests for the new source tracking features.",
          "dependencies": [
            1
          ],
          "details": "Define performance objectives (e.g., response times, throughput, resource utilization). Specify test scenarios for concurrent users, data volume, and sustained load to identify bottlenecks and ensure scalability.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 6,
          "title": "Develop Cross-Platform Compatibility Test Plan",
          "description": "Create a plan for testing the new source tracking features across different browsers, operating systems, and devices.",
          "dependencies": [
            1
          ],
          "details": "Identify target platforms, browsers, and devices. Define test scenarios to ensure consistent functionality, UI rendering, and performance across all specified environments.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 7,
          "title": "Define Automation Strategy and Test Coverage Metrics",
          "description": "Specify the automation strategy for all test types and define key metrics for measuring test coverage.",
          "dependencies": [
            2,
            3,
            4,
            5,
            6
          ],
          "details": "Determine which test types will be automated (e.g., unit, integration, some E2E, performance). Select automation tools and frameworks. Define metrics such as code coverage, requirement coverage, and defect escape rate.",
          "status": "done",
          "prdSource": null
        },
        {
          "id": 8,
          "title": "Outline Test Suite Review and Maintenance Plan",
          "description": "Establish a process for regular review, update, and maintenance of the test suites for the new source tracking features.",
          "dependencies": [
            7
          ],
          "details": "Define frequency for test suite reviews (e.g., sprintly, release-based). Specify criteria for updating test cases, removing obsolete tests, and adding new ones based on feature changes or defect analysis. Assign ownership for maintenance.",
          "status": "done",
          "prdSource": null
        }
      ],
      "prdSource": null
    },
    {
      "id": 29,
      "title": "Implement 'Append + Auto-Expand' Menu Option",
      "description": "Add a new menu option \"➕ Append new tasks + Auto-expand complex tasks\" to the existing PRD parsing menu in Commander.js and Inquirer.js. This option should appear when existing tasks are detected during PRD parsing and be clearly distinguishable from the existing \"Append new tasks\" option. Ensure backward compatibility with existing menu options.",
      "details": "Extend the `parse-prd` command in Commander.js to include a new option. Use Inquirer.js to present this option to the user. The new option's label should be '➕ Append new tasks + Auto-expand complex tasks'. This option should only be visible if existing tasks are detected, indicating a scenario where appending is relevant. Ensure the existing 'Append new tasks' option remains available and functional. The implementation should maintain the current menu structure and navigation using arrow keys and enter.",
      "testStrategy": "Unit tests for the Commander.js command and Inquirer.js prompt to ensure the new option is displayed correctly under the specified conditions and is selectable. Manual testing to verify the option's appearance and selection in the CLI, and to confirm existing options remain functional.",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Identify and Refactor Menu Option Generation Logic",
          "description": "Locate the existing code responsible for generating the PRD parsing menu options in Commander.js and Inquirer.js. Refactor this logic to allow for conditional display of menu items based on whether existing tasks are detected.",
          "dependencies": [],
          "details": "Examine `commands/parse-prd.js` and related Inquirer.js prompt definitions. Identify the array or function that constructs the choices for the 'What do you want to do?' prompt. Create a helper function or modify the existing logic to accept a flag indicating the presence of existing tasks.",
          "status": "done",
          "testStrategy": "Manually test the `parse-prd` command with and without existing tasks to ensure the original menu options are still displayed correctly and that the new conditional logic can be integrated without breaking existing functionality.",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        },
        {
          "id": 2,
          "title": "Implement Detection of Existing Tasks",
          "description": "Add logic to the `parse-prd` command to determine if existing tasks are present in the target project/file before presenting the menu options. This detection will drive the conditional display of the new menu item.",
          "dependencies": [
            1
          ],
          "details": "Before the Inquirer.js prompt is displayed, implement a check (e.g., by reading the project's task list or a specific file) to ascertain if tasks already exist. Store this state in a boolean variable that can be passed to the menu generation logic identified in subtask 1.",
          "status": "done",
          "testStrategy": "Create test cases: one where the target has existing tasks, and one where it does not. Verify that the boolean flag correctly reflects the presence or absence of tasks.",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        },
        {
          "id": 3,
          "title": "Add 'Append + Auto-Expand' Menu Option",
          "description": "Integrate the new menu option '➕ Append new tasks + Auto-expand complex tasks' into the Inquirer.js prompt choices. This option should only be visible when existing tasks are detected.",
          "dependencies": [
            1,
            2
          ],
          "details": "Modify the menu option generation logic (refactored in subtask 1) to conditionally include the new choice. The choice object should have a `name` property set to '➕ Append new tasks + Auto-expand complex tasks' and a distinct `value` (e.g., 'appendAndAutoExpand'). Ensure its `when` property in Inquirer.js is linked to the boolean flag from subtask 2.",
          "status": "done",
          "testStrategy": "Run `parse-prd` command: 1) With no existing tasks - verify the new option is NOT shown. 2) With existing tasks - verify the new option IS shown alongside 'Append new tasks' and other existing options.",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        },
        {
          "id": 4,
          "title": "Implement Logic for 'Append + Auto-Expand' Option",
          "description": "Develop the backend logic that executes when the '➕ Append new tasks + Auto-expand complex tasks' option is selected. This logic should append new tasks and then automatically expand any complex tasks.",
          "dependencies": [
            3
          ],
          "details": "In the `parse-prd` command's action handler, add a new `case` or `if` condition for the 'appendAndAutoExpand' value. This logic should first call the existing 'append new tasks' functionality. Subsequently, it needs to identify newly appended complex tasks and trigger their auto-expansion (this might involve calling an existing 'expand' utility or implementing new logic).",
          "status": "done",
          "testStrategy": "Create a PRD with new tasks, some of which are complex. Run `parse-prd`, select the new option. Verify that new tasks are appended and that complex tasks are automatically expanded (e.g., by checking the generated task structure or output).",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        },
        {
          "id": 5,
          "title": "Refine User Experience and Documentation",
          "description": "Ensure the new menu option is clearly distinguishable, and update any relevant documentation or help text for the `parse-prd` command.",
          "dependencies": [
            4
          ],
          "details": "Review the menu display for clarity. The '➕' prefix helps distinguish it, but consider if any additional spacing or formatting is needed. Update the `README.md` or any internal developer documentation that describes the `parse-prd` command and its options. Add a brief explanation of what 'auto-expand complex tasks' means.",
          "status": "done",
          "testStrategy": "Review the command-line output for the `parse-prd` menu. Check the updated documentation for accuracy and completeness regarding the new option. Conduct a final end-to-end test to ensure all options function as expected and the user flow is intuitive.",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        }
      ],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
        "fileName": "append-expand-prd-option.txt",
        "parsedDate": "2025-06-01T06:23:00.242Z",
        "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
        "fileSize": 11286
      }
    },
    {
      "id": 30,
      "title": "Integrate Auto-Expansion Logic into PRD Parsing",
      "description": "Integrate the automatic task expansion logic into the PRD parsing workflow. When the 'Append + Auto-Expand' option is selected, the system should identify complex tasks suitable for expansion and automatically expand them into subtasks using existing AI models and expansion criteria. Only tasks meeting the defined expansion criteria (complexity, description length, feature scope) should be expanded.",
      "details": "Modify the `parse-prd` command's logic to incorporate the auto-expansion step after initial task parsing when the new option is chosen. Reuse the existing task expansion logic and AI models that are currently used by the `expand` command. Implement a mechanism to identify 'complex' tasks based on criteria such as description length, presence of keywords indicating complexity, or predefined feature scope. This identification should precede the expansion process. Ensure that the expansion process maintains all existing functionality and quality standards of the standalone expansion command. Provide progress feedback to the user during this process.",
      "testStrategy": "Unit tests for the integration of expansion logic within the parsing flow. Integration tests with various PRD examples (small, large, mixed complexity) to verify that complex tasks are correctly identified and expanded, while simple tasks are not. Performance testing to ensure the auto-expansion adds no more than 30% to the total parsing time. Verify that the progress feedback is displayed correctly.",
      "priority": "high",
      "dependencies": [
        29
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Add 'Append + Auto-Expand' Option to PRD Parsing Command",
          "description": "Modify the `parse-prd` command-line interface (CLI) to include a new option, e.g., `--auto-expand` or `--append-auto-expand`. This option will trigger the auto-expansion logic during PRD parsing.",
          "dependencies": [],
          "details": "Update the `parse-prd` command's argument parser (e.g., `argparse` in Python) to recognize and store the state of this new option. Ensure it's mutually exclusive or appropriately combined with existing append options if necessary. The option should be a boolean flag.",
          "status": "pending",
          "testStrategy": "Run `parse-prd --help` to verify the new option is listed. Execute `parse-prd` with and without the new option to ensure it doesn't break existing functionality when not selected.",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        },
        {
          "id": 2,
          "title": "Implement Task Complexity Identification Logic",
          "description": "Develop a mechanism within the PRD parsing workflow to identify 'complex' tasks that are candidates for auto-expansion. This mechanism should be triggered only when the 'Append + Auto-Expand' option is enabled.",
          "dependencies": [
            1
          ],
          "details": "After initial task parsing, iterate through the generated tasks. Implement a function `is_complex_task(task)` that returns a boolean. Criteria for complexity should include: description length (e.g., > N characters), presence of keywords (e.g., 'integrate', 'implement', 'design', 'complex'), or predefined feature scope tags. This function will mark tasks for potential expansion.",
          "status": "pending",
          "testStrategy": "Prepare PRD examples with tasks of varying complexity (short descriptions, long descriptions, keywords, no keywords). Run `parse-prd --auto-expand` and verify that only the intended tasks are marked as complex candidates (e.g., by logging or inspecting an intermediate data structure).",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        },
        {
          "id": 3,
          "title": "Integrate Existing Task Expansion Logic",
          "description": "Incorporate the existing task expansion logic (currently used by the `expand` command) into the `parse-prd` workflow. This integration should occur after initial parsing and complexity identification, and only for tasks marked as complex.",
          "dependencies": [
            2
          ],
          "details": "Refactor the existing expansion logic from the `expand` command into a reusable module or function. Call this function for each task identified as complex by the previous step. Ensure the expansion process uses the same AI models and criteria as the standalone `expand` command. Handle the output of the expansion (subtasks) by replacing the original complex task with its expanded subtasks in the parsed task list.",
          "status": "pending",
          "testStrategy": "Use a PRD with a known complex task that expands predictably with the standalone `expand` command. Run `parse-prd --auto-expand` on this PRD and verify that the complex task is correctly replaced by its expected subtasks, maintaining their structure and content.",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        },
        {
          "id": 4,
          "title": "Implement User Progress Feedback",
          "description": "Provide real-time progress feedback to the user during the auto-expansion process, especially when multiple complex tasks are being expanded, as AI model calls can be time-consuming.",
          "dependencies": [
            3
          ],
          "details": "Add logging or print statements to indicate: 1) when auto-expansion starts, 2) which task is currently being processed for expansion (e.g., 'Expanding task: 'Task Title''), and 3) when expansion for a task is complete. Consider using a progress bar or spinner for a better user experience if feasible.",
          "status": "pending",
          "testStrategy": "Run `parse-prd --auto-expand` on a PRD with several complex tasks. Observe the console output to ensure progress messages are displayed correctly and provide meaningful feedback during the expansion process.",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        },
        {
          "id": 5,
          "title": "End-to-End Validation and Refinement",
          "description": "Perform comprehensive end-to-end testing of the integrated auto-expansion feature. Refine the complexity identification criteria and expansion integration based on test results to ensure quality and adherence to requirements.",
          "dependencies": [
            4
          ],
          "details": "Test with a variety of PRD documents, including those with no complex tasks, a few complex tasks, and many complex tasks. Verify that: 1) non-complex tasks are not expanded, 2) complex tasks are expanded correctly, 3) the overall task hierarchy is maintained, 4) performance is acceptable, and 5) error handling is robust. Adjust complexity thresholds (e.g., description length, keyword list) and AI model parameters if necessary to optimize expansion quality.",
          "status": "pending",
          "testStrategy": "Develop a suite of integration tests covering various PRD scenarios. Automate these tests if possible. Manually review the output of expanded tasks for accuracy, relevance, and completeness. Conduct performance profiling to identify and address any bottlenecks.",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        }
      ],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
        "fileName": "append-expand-prd-option.txt",
        "parsedDate": "2025-06-01T06:23:00.242Z",
        "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
        "fileSize": 11286
      }
    },
    {
      "id": 31,
      "title": "Implement PRD Context Inheritance for Auto-Generated Subtasks",
      "description": "Ensure that all subtasks automatically generated through the auto-expansion process inherit the complete PRD source metadata (filePath, fileName, fileHash, parsedDate) from their parent tasks. This is crucial for maintaining traceability of requirements from subtasks back to the original PRD.",
      "details": "During the auto-expansion process, for each subtask generated, copy the `prdSource` metadata from its parent task. This includes `filePath`, `fileName`, `fileHash`, and `parsedDate`. The `prdSource` field for subtasks should be a direct copy of the parent's `prdSource`. Verify that existing traceability commands (e.g., `show-prd-source`, `tasks-from-prd`) correctly display and utilize this inherited information for subtasks. Ensure that change detection mechanisms also work properly with subtasks having inherited PRD context.",
      "testStrategy": "Unit tests to confirm that subtasks are created with the correct inherited `prdSource` metadata. Integration tests using `task-master show-prd-source --id=<subtask_id>` and `task-master tasks-from-prd --prd=<prd_file>` to verify that the PRD source information is accurately displayed and traceable for auto-generated subtasks. Test with various PRDs to ensure consistent inheritance across different scenarios.",
      "priority": "high",
      "dependencies": [
        30
      ],
      "status": "done",
      "subtasks": [],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
        "fileName": "append-expand-prd-option.txt",
        "parsedDate": "2025-06-01T06:23:00.242Z",
        "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
        "fileSize": 11286
      }
    },
    {
      "id": 32,
      "title": "Refine and Implement Intelligent Expansion Criteria",
      "description": "Refine and implement intelligent criteria for determining which tasks should be automatically expanded. This will prevent over-granular task structures and ensure only appropriate tasks are expanded based on their complexity, description length, and feature scope.",
      "details": "Develop and implement a configurable set of rules or an algorithm to assess task complexity. This could involve analyzing the length of the task description, the presence of specific keywords (e.g., 'implement', 'integrate', 'design', 'develop'), the number of sub-requirements implied in the description, or a predefined feature scope. The criteria should be flexible enough to be adjusted if needed. The goal is to ensure that only tasks that genuinely benefit from further breakdown are automatically expanded, avoiding unnecessary subtask generation.",
      "testStrategy": "Unit tests for the complexity assessment algorithm with various task descriptions. Integration tests with PRDs containing tasks of varying complexities to verify that the expansion criteria correctly identify and trigger expansion only for the intended tasks. User acceptance testing with different PRD types to validate the appropriateness of the generated subtask granularity.",
      "priority": "medium",
      "dependencies": [
        30
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Define Initial Expansion Criteria and Data Sources",
          "description": "Identify and document the initial set of criteria for intelligent task expansion, including potential data sources within the task object (e.g., description length, keywords, estimated complexity field).",
          "dependencies": [],
          "details": "Collaborate with product/design to establish a baseline for what constitutes a 'complex' task warranting expansion. Focus on readily available task attributes. Document these criteria clearly, perhaps as a configuration schema or a simple rule set.",
          "status": "pending",
          "testStrategy": "Review documented criteria with stakeholders for alignment and completeness.",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        },
        {
          "id": 2,
          "title": "Develop Task Attribute Extraction Module",
          "description": "Implement a module responsible for extracting relevant attributes from a given task object based on the defined criteria (e.g., description length, keyword presence, estimated complexity value).",
          "dependencies": [
            1
          ],
          "details": "Create a utility function or class that takes a task object as input and returns a structured object containing extracted attributes. For keywords, use a predefined list. For description length, count characters or words. Consider using a simple NLP library if keyword matching needs to be more sophisticated (e.g., stemming).",
          "status": "pending",
          "testStrategy": "Unit tests for the extraction module, ensuring it correctly extracts attributes for various task inputs (e.g., long/short descriptions, descriptions with/without keywords, tasks with/without complexity estimates).",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        },
        {
          "id": 3,
          "title": "Implement Configurable Expansion Rule Engine",
          "description": "Develop a configurable rule engine that evaluates the extracted task attributes against the defined expansion criteria to determine if a task should be automatically expanded.",
          "dependencies": [
            2
          ],
          "details": "Design a flexible rule engine that can load rules from a configuration. Rules could be simple boolean expressions (e.g., 'description_length > X AND has_keyword_Y'). The engine should take the output of the attribute extraction module and return a boolean indicating expansion necessity. Consider using a simple JSON-based rule configuration.",
          "status": "pending",
          "testStrategy": "Unit tests for the rule engine with various rule configurations and attribute sets, ensuring correct expansion decisions. Test edge cases for each rule type.",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        },
        {
          "id": 4,
          "title": "Integrate Expansion Logic into Task Creation/Update Workflow",
          "description": "Integrate the developed expansion rule engine into the existing task creation and update workflows to automatically trigger expansion based on the evaluation.",
          "dependencies": [
            3
          ],
          "details": "Identify the appropriate hooks in the task creation/update process where the expansion logic should be invoked. This might be a service layer call after a task is saved. Ensure that the expansion process is asynchronous if it involves significant computation or external calls, to avoid blocking the main workflow. Handle cases where expansion might fail gracefully.",
          "status": "pending",
          "testStrategy": "Integration tests simulating task creation/update with different task data, verifying that tasks meeting expansion criteria are flagged for expansion and those that don't are not. Manual end-to-end testing of the workflow.",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        },
        {
          "id": 5,
          "title": "Develop Admin Interface for Criteria Management and Monitoring",
          "description": "Create a basic administrative interface or configuration mechanism to allow non-developers to view and adjust the expansion criteria and monitor expansion activity.",
          "dependencies": [
            4
          ],
          "details": "Implement a simple UI or API endpoint that allows viewing and modifying the rule configuration (e.g., keyword lists, length thresholds). Also, consider adding logging or metrics to track how often tasks are expanded by the intelligent criteria, and which criteria are most frequently met. This will aid in future refinement.",
          "status": "pending",
          "testStrategy": "Manual testing of the admin interface to ensure criteria can be updated and saved correctly. Verify that changes to criteria reflect in the expansion behavior. Review logs/metrics to confirm monitoring is functional.",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        }
      ],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
        "fileName": "append-expand-prd-option.txt",
        "parsedDate": "2025-06-01T06:23:00.242Z",
        "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
        "fileSize": 11286
      }
    },
    {
      "id": 33,
      "title": "Implement User Feedback and Progress Indication",
      "description": "Provide clear and informative feedback to the user during the 'Append + Auto-Expand' process, including progress indicators and a summary of the results (e.g., number of tasks appended, number of tasks expanded, number of subtasks generated).",
      "details": "Integrate progress indicators (e.g., spinners, percentage complete) into the CLI output during the PRD parsing and auto-expansion phases. Upon completion, display a summary report to the user. This report should include: the total number of new tasks appended, the number of complex tasks identified for expansion, the number of subtasks generated, and any relevant warnings or errors. This feedback should enhance the user experience by providing visibility into the enhanced parsing process.",
      "testStrategy": "Manual testing to observe the progress indicators during the parsing and expansion process. Automated tests to verify the content and format of the summary report. Test with both small and large PRDs to ensure consistent and accurate feedback. Verify that error messages are displayed appropriately if any issues occur during the process.",
      "priority": "medium",
      "dependencies": [
        30
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Define and Capture Key Metrics for Feedback",
          "description": "Identify and instrument the 'Append + Auto-Expand' process to capture all necessary metrics for user feedback and the final summary report. This includes counts for appended tasks, expanded tasks, generated subtasks, and any warnings/errors.",
          "dependencies": [],
          "details": "Modify the existing 'Append + Auto-Expand' logic to increment counters for: 1. New tasks appended from PRD. 2. Complex tasks identified for auto-expansion. 3. Subtasks successfully generated during expansion. 4. Any warnings or errors encountered during parsing or expansion. These metrics should be stored in an accessible data structure.",
          "status": "pending",
          "testStrategy": "Unit tests to ensure counters increment correctly under various scenarios (e.g., empty PRD, PRD with new tasks, PRD with expandable tasks, PRD with errors).",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        },
        {
          "id": 2,
          "title": "Implement Real-time Progress Indicators in CLI",
          "description": "Integrate dynamic progress indicators (e.g., spinners, percentage) into the CLI output during the 'Append + Auto-Expand' process to provide immediate user feedback.",
          "dependencies": [
            1
          ],
          "details": "Utilize a suitable CLI library (e.g., 'ora' for spinners, 'cli-progress' for progress bars) to display progress during the distinct phases: PRD parsing/appending and task auto-expansion. The indicators should update as the process runs, giving the user a sense of activity and preventing perceived freezes. Consider displaying 'Parsing PRD...' and 'Expanding tasks...' messages.",
          "status": "pending",
          "testStrategy": "Manual testing to observe the CLI output during execution, ensuring spinners/progress bars appear, update, and disappear correctly. Verify no console clutter.",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        },
        {
          "id": 3,
          "title": "Develop Final Summary Report Generation Logic",
          "description": "Create the logic to compile and format the captured metrics into a clear, concise summary report to be displayed upon completion of the 'Append + Auto-Expand' process.",
          "dependencies": [
            1
          ],
          "details": "After the 'Append + Auto-Expand' process concludes, retrieve the metrics captured in Subtask 1. Format these into a user-friendly report string. The report should explicitly state: 'Total new tasks appended: X', 'Tasks identified for expansion: Y', 'Subtasks generated: Z', and 'Warnings/Errors: W'.",
          "status": "pending",
          "testStrategy": "Unit tests for the report generation function, providing various metric inputs (e.g., all zeros, positive numbers, numbers with errors) and asserting the correctness of the generated report string.",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        },
        {
          "id": 4,
          "title": "Integrate Progress and Summary Output into CLI Workflow",
          "description": "Hook the real-time progress indicators and the final summary report into the main 'Append + Auto-Expand' CLI command workflow.",
          "dependencies": [
            2,
            3
          ],
          "details": "Modify the main CLI command handler for 'Append + Auto-Expand' to: 1. Start the progress indicator before initiating the parsing/expansion. 2. Update or switch indicators as phases change. 3. Stop the progress indicator upon completion. 4. Print the generated summary report to the console after the process finishes.",
          "status": "pending",
          "testStrategy": "End-to-end integration tests via CLI commands. Run the 'Append + Auto-Expand' command with various PRD inputs (empty, simple, complex, erroneous) and verify that both real-time progress is shown and the final summary report is accurate and displayed correctly.",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        },
        {
          "id": 5,
          "title": "Refine User Messaging and Error Handling Display",
          "description": "Review and refine all user-facing messages, including progress updates, warnings, and error displays, to ensure clarity, consistency, and helpfulness.",
          "dependencies": [
            4
          ],
          "details": "Standardize the language used in progress messages, warning messages, and error reports. Ensure that warnings and errors captured in Subtask 1 are clearly presented in the final summary or immediately after they occur, providing actionable information to the user. Consider color-coding for warnings/errors if supported by the CLI library.",
          "status": "pending",
          "testStrategy": "Manual review of all CLI output during various execution paths, specifically focusing on the clarity and helpfulness of messages, warnings, and errors. Verify consistent formatting and tone.",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
            "fileName": "append-expand-prd-option.txt",
            "parsedDate": "2025-06-01T06:23:00.242Z",
            "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
            "fileSize": 11286
          }
        }
      ],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/append-expand-prd-option.txt",
        "fileName": "append-expand-prd-option.txt",
        "parsedDate": "2025-06-01T06:23:00.242Z",
        "fileHash": "f50675882b47c882d45a8aed13eb8d07574c30a5675bc461e89c9cca50e96442",
        "fileSize": 11286
      }
    },
    {
      "id": 34,
      "title": "Terminal Kanban Board Layout and Display",
      "description": "Implement the foundational terminal-based Kanban board layout using ASCII art and box drawing characters. This includes setting up the chosen terminal UI framework (Blessed.js or Ink.js) and rendering the three status columns: 'pending', 'in-progress', and 'done'. Each column should display a task count in its header and a 'No tasks' placeholder if empty. The board must dynamically adapt to terminal width and height.",
      "details": "Utilize Blessed.js or Ink.js for terminal UI rendering. Create a layout that divides the terminal into three main columns. Use ASCII art and box drawing characters to visually separate these columns. Implement logic to dynamically adjust column widths and heights based on the terminal's dimensions. For each column, display a header with the column name (e.g., '📋 IN PROGRESS') and the current task count. If a column has no tasks, display 'No tasks'. Ensure consistent styling with existing TaskMaster UI, including emojis and colors. Integrate with existing TaskMaster utilities for initial JSON reading to populate the board with tasks.",
      "testStrategy": "Verify that the terminal board displays three distinct columns with correct headers and task counts. Test dynamic resizing by changing terminal window dimensions. Confirm 'No tasks' message appears in empty columns. Visually inspect for consistent ASCII art and styling across different terminal environments (Windows PowerShell, macOS Terminal, Linux terminals).",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Initialize Terminal UI Framework",
          "description": "Set up the chosen terminal UI framework (Blessed.js or Ink.js) to create a basic interactive terminal application.",
          "dependencies": [],
          "details": "This involves installing the framework, setting up the main application instance, and creating a basic screen or app component.",
          "status": "done",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
            "fileName": "kanban-view-prd.txt",
            "parsedDate": "2025-06-01T07:27:35.658Z",
            "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
            "fileSize": 18300
          }
        },
        {
          "id": 2,
          "title": "Design and Render Kanban Columns",
          "description": "Create and render the three main Kanban columns ('pending', 'in-progress', 'done') using ASCII art or the chosen UI framework's drawing capabilities.",
          "dependencies": [
            1
          ],
          "details": "Each column should have a distinct visual boundary. Consider using borders or background colors to differentiate them.",
          "status": "done",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
            "fileName": "kanban-view-prd.txt",
            "parsedDate": "2025-06-01T07:27:35.658Z",
            "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
            "fileSize": 18300
          }
        },
        {
          "id": 3,
          "title": "Implement Dynamic Column Resizing",
          "description": "Develop logic to dynamically resize the Kanban columns based on the current terminal dimensions, ensuring they always fit the screen.",
          "dependencies": [
            2
          ],
          "details": "This will involve listening for terminal resize events and recalculating column widths to distribute space evenly or proportionally.",
          "status": "done",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
            "fileName": "kanban-view-prd.txt",
            "parsedDate": "2025-06-01T07:27:35.658Z",
            "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
            "fileSize": 18300
          }
        },
        {
          "id": 4,
          "title": "Display Column Headers and Task Counts",
          "description": "Add headers to each Kanban column, displaying the column name and a dynamic count of tasks within that column. Include a 'No tasks' placeholder when a column is empty.",
          "dependencies": [
            3
          ],
          "details": "The task count should be updated as tasks are added or moved. The 'No tasks' message should appear centrally within an empty column.",
          "status": "done",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
            "fileName": "kanban-view-prd.txt",
            "parsedDate": "2025-06-01T07:27:35.658Z",
            "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
            "fileSize": 18300
          }
        },
        {
          "id": 5,
          "title": "Integrate Initial JSON Data Loading",
          "description": "Implement functionality to load initial task data from a JSON file and populate the respective Kanban columns on application startup.",
          "dependencies": [
            4
          ],
          "details": "This involves parsing the JSON data and mapping tasks to their corresponding 'pending', 'in-progress', or 'done' columns, updating task counts accordingly.",
          "status": "done",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
            "fileName": "kanban-view-prd.txt",
            "parsedDate": "2025-06-01T07:27:35.658Z",
            "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
            "fileSize": 18300
          }
        }
      ],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
        "fileName": "kanban-view-prd.txt",
        "parsedDate": "2025-06-01T07:27:35.658Z",
        "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
        "fileSize": 18300
      }
    },
    {
      "id": 35,
      "title": "ASCII Task Card Design and Metadata Display",
      "description": "Design and implement the ASCII task cards to display essential TaskMaster metadata within the Kanban board columns. Each card should clearly show the task's ID, title, priority, dependencies count, and a PRD source indicator. Priority should be visually represented with colored text and symbols, and long titles should be truncated with an ellipsis.",
      "details": "Within the columns established in Task 34, render individual task cards using ASCII box drawing characters for visual separation. For each task, display its ID, title, priority (e.g., '🔴 High', '🟡 Medium', '🟢 Low' using Chalk.js for colors), dependencies count (e.g., 'Deps: 2'), and a '📄' icon if the task has a PRD source. Implement logic to truncate long task titles with '...' and ensure the full title is available for display in a status bar when the task is selected. Cards must fit within the defined column width constraints.",
      "testStrategy": "Verify that all required metadata (ID, title, priority, dependencies count, PRD source indicator) is correctly displayed on each task card. Test priority color coding and symbol representation. Confirm title truncation with ellipsis and ensure the full title is accessible. Check that cards are properly formatted within column boundaries and use correct ASCII box drawing characters.",
      "priority": "high",
      "dependencies": [
        34
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Define ASCII Task Card Structure",
          "description": "Design the basic ASCII box drawing structure for an individual task card, including borders and internal divisions for different data fields.",
          "dependencies": [],
          "details": "This involves sketching out the ASCII characters for corners, horizontal and vertical lines to form the card's outline and internal sections.",
          "status": "done",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
            "fileName": "kanban-view-prd.txt",
            "parsedDate": "2025-06-01T07:27:35.658Z",
            "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
            "fileSize": 18300
          }
        },
        {
          "id": 2,
          "title": "Implement Core Task Data Display Logic",
          "description": "Develop the logic to display task ID, title, priority (with appropriate ASCII color/symbol representation), dependencies count, and a PRD source indicator within the defined ASCII card structure.",
          "dependencies": [
            1
          ],
          "details": "This subtask will involve mapping task data fields to specific positions within the ASCII card and implementing conditional rendering for priority (e.g., '!!!' for high, '!!' for medium, '!' for low) and a specific ASCII character for PRD source.",
          "status": "done",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
            "fileName": "kanban-view-prd.txt",
            "parsedDate": "2025-06-01T07:27:35.658Z",
            "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
            "fileSize": 18300
          }
        },
        {
          "id": 3,
          "title": "Develop Title Truncation and Full Title Accessibility",
          "description": "Implement a mechanism to truncate long task titles with an ellipsis (...) while ensuring the full title can be accessed (e.g., via a tooltip or hover effect in a terminal emulator if supported, or a separate display command).",
          "dependencies": [
            2
          ],
          "details": "This requires calculating available space for the title within the ASCII card and applying truncation logic. Consideration should be given to how the full title will be revealed.",
          "status": "done",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
            "fileName": "kanban-view-prd.txt",
            "parsedDate": "2025-06-01T07:27:35.658Z",
            "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
            "fileSize": 18300
          }
        },
        {
          "id": 4,
          "title": "Ensure Card Column Width Compliance and Styling Consistency",
          "description": "Verify that the rendered ASCII task cards fit within predefined column width constraints and maintain consistent styling across all elements.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "This involves testing the rendering with various data lengths and ensuring that the ASCII art remains intact and visually appealing within the specified column width. It also includes reviewing character alignment and spacing for consistency.",
          "status": "done",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
            "fileName": "kanban-view-prd.txt",
            "parsedDate": "2025-06-01T07:27:35.658Z",
            "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
            "fileSize": 18300
          }
        }
      ],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
        "fileName": "kanban-view-prd.txt",
        "parsedDate": "2025-06-01T07:27:35.658Z",
        "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
        "fileSize": 18300
      }
    },
    {
      "id": 36,
      "title": "Keyboard Navigation and Status Updates",
      "description": "Enable keyboard navigation within the Kanban board to allow users to move between tasks and columns, select tasks, and update their status. Implement shortcuts for moving selected tasks between 'pending', 'in-progress', and 'done' columns, ensuring immediate visual feedback and persistent updates to tasks.json.",
      "details": "Implement keyboard event handling using Blessed.js or Ink.js's built-in capabilities. Allow arrow keys to navigate between tasks within a column and between columns. The Enter key should select/highlight a task, providing clear visual feedback (e.g., a different background color). Implement number keys (1, 2, 3) to move the currently selected task to the 'pending', 'in-progress', or 'done' column respectively. Upon a status change, update the task's status in the in-memory data structure and persist the change to tasks.json using existing TaskMaster utilities. Immediately refresh the board display and update column task counts.",
      "testStrategy": "Test arrow key navigation across tasks and columns. Verify task selection and highlighting. Confirm that pressing 1, 2, or 3 correctly moves the selected task to the corresponding column. Check that the task's status is updated in tasks.json and that the board visually reflects the change immediately, including updated column task counts. Test status updates for all three statuses.",
      "priority": "high",
      "dependencies": [
        34,
        35
      ],
      "status": "done",
      "subtasks": [],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
        "fileName": "kanban-view-prd.txt",
        "parsedDate": "2025-06-01T07:27:35.658Z",
        "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
        "fileSize": 18300
      }
    },
    {
      "id": 37,
      "title": "Quick Task Operations via Keyboard",
      "description": "Implement quick task operations accessible via keyboard shortcuts from the Kanban view. This includes viewing detailed task information, deleting tasks with a confirmation prompt, entering inline edit mode for task titles, showing task ID and metadata, and refreshing the board. All operations must update tasks.json and refresh the display immediately.",
      "details": "For a selected task, implement the following keyboard shortcuts: 'V' to show detailed task information in a bottom panel, 'D' to delete the selected task (with a confirmation prompt), 'E' to open an inline edit mode for the task title, 'I' to show task ID and metadata in the status bar, and 'R' to refresh the board from tasks.json. Ensure all operations that modify task data (delete, edit) use existing TaskMaster utilities to update tasks.json and trigger an immediate board refresh. Maintain data consistency with existing TaskMaster commands.",
      "testStrategy": "Test each quick operation ('V', 'D', 'E', 'I', 'R') with a selected task. Verify that 'V' displays correct detailed information. Confirm 'D' prompts for confirmation and successfully deletes the task from tasks.json and the board. Test 'E' for inline title editing and persistence. Check 'I' for correct ID/metadata display. Verify 'R' refreshes the board with the latest data from tasks.json. Ensure all operations maintain data consistency and update the board visually.",
      "priority": "medium",
      "dependencies": [
        35
      ],
      "status": "done",
      "subtasks": [],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
        "fileName": "kanban-view-prd.txt",
        "parsedDate": "2025-06-01T07:27:35.658Z",
        "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
        "fileSize": 18300
      }
    },
    {
      "id": 38,
      "title": "Terminal Board Navigation and Controls & Menu Integration",
      "description": "Implement terminal-based navigation controls and board management features, including filtering, searching, displaying board statistics, showing a help overlay, and exiting the Kanban view. Also, ensure seamless integration with the existing TaskMaster interactive menu system.",
      "details": "Implement the following keyboard shortcuts for board navigation and controls: 'F' to toggle filter mode (priority, PRD source, status), '/' to open search mode, 'S' to show board statistics (total tasks, completion %) in the status bar, 'H' to display a help overlay with all keyboard shortcuts, and 'Q' to exit the Kanban view and return to the TaskMaster menu. Implement Tab key functionality to cycle through different board sections (columns, filters, help). Ensure the status bar consistently displays the current mode and available shortcuts. Integrate the Kanban board view as a new option ('📊 Kanban Board View') within the existing TaskMaster 'Task Operations' submenu, ensuring a smooth transition into and out of the Kanban interface.",
      "testStrategy": "Test each navigation and control shortcut ('F', '/', 'S', 'H', 'Q', Tab). Verify that 'F' toggles filter options, '/' activates search, 'S' displays correct statistics, and 'H' shows the help overlay. Confirm 'Q' exits the Kanban view and returns to the TaskMaster menu. Test Tab key cycling through board sections. Verify that the Kanban board option is correctly integrated into the TaskMaster 'Task Operations' submenu and that selecting it launches the board as expected. Ensure the status bar updates correctly with mode and shortcuts.",
      "priority": "medium",
      "dependencies": [
        34
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Design and Implement Keyboard Shortcut Listener",
          "description": "Develop a global keyboard event listener to capture 'F', '/', 'S', 'H', and 'Q' key presses and trigger corresponding actions. This includes mapping keys to specific functions (filter, search, statistics, help, exit).",
          "dependencies": [],
          "details": "This subtask involves setting up the core mechanism for keyboard navigation. It needs to be robust enough to avoid conflicts with other inputs and handle different states of the application.",
          "status": "done",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
            "fileName": "kanban-view-prd.txt",
            "parsedDate": "2025-06-01T07:27:35.658Z",
            "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
            "fileSize": 18300
          }
        },
        {
          "id": 2,
          "title": "Develop Filter Mode UI and Logic",
          "description": "Create the user interface for the filter mode, allowing users to apply various filters to the Kanban board. Implement the backend logic to process filter criteria and update the displayed tasks accordingly.",
          "dependencies": [
            1
          ],
          "details": "This subtask requires designing intuitive filter options (e.g., by assignee, status, due date) and implementing the filtering algorithm. It should integrate with the keyboard shortcut for 'F'.",
          "status": "done",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
            "fileName": "kanban-view-prd.txt",
            "parsedDate": "2025-06-01T07:27:35.658Z",
            "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
            "fileSize": 18300
          }
        },
        {
          "id": 3,
          "title": "Develop Search Mode UI and Logic",
          "description": "Design and implement the UI for the search mode, enabling users to search for tasks within the Kanban board. Develop the logic to perform efficient searches and highlight/display matching tasks.",
          "dependencies": [
            1
          ],
          "details": "This subtask involves creating a search input field and implementing a search algorithm (e.g., fuzzy search, keyword matching). It should integrate with the keyboard shortcut for '/'.",
          "status": "done",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
            "fileName": "kanban-view-prd.txt",
            "parsedDate": "2025-06-01T07:27:35.658Z",
            "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
            "fileSize": 18300
          }
        },
        {
          "id": 4,
          "title": "Implement Statistics Display and Help Overlay",
          "description": "Develop the UI and logic to display board statistics (e.g., task counts per column, completed tasks). Create a help overlay that provides information on keyboard shortcuts and board functionalities.",
          "dependencies": [
            1
          ],
          "details": "This subtask involves calculating and presenting relevant board metrics. The help overlay should be easily accessible and informative, integrating with 'S' and 'H' keyboard shortcuts respectively.",
          "status": "done",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
            "fileName": "kanban-view-prd.txt",
            "parsedDate": "2025-06-01T07:27:35.658Z",
            "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
            "fileSize": 18300
          }
        },
        {
          "id": 5,
          "title": "Integrate Kanban Board into TaskMaster 'Task Operations' Submenu",
          "description": "Modify the existing TaskMaster menu structure to include the Kanban board view under the 'Task Operations' submenu. Ensure proper menu navigation and state management when entering and exiting the Kanban interface.",
          "dependencies": [],
          "details": "This subtask requires understanding the existing menu system and seamlessly embedding the new Kanban view. It involves updating menu configurations and potentially routing logic.",
          "status": "done",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
            "fileName": "kanban-view-prd.txt",
            "parsedDate": "2025-06-01T07:27:35.658Z",
            "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
            "fileSize": 18300
          }
        },
        {
          "id": 6,
          "title": "Ensure Smooth Transitions and Status Bar Updates",
          "description": "Implement mechanisms to ensure smooth visual and functional transitions when entering and exiting the Kanban interface. Develop logic to update the application's status bar to reflect the current mode or relevant information.",
          "dependencies": [
            2,
            3,
            4,
            5
          ],
          "details": "This subtask focuses on user experience, ensuring that switching between modes (e.g., filter, search) and entering/exiting the Kanban board is fluid. It also involves updating the status bar to provide contextual feedback to the user.",
          "status": "done",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
            "fileName": "kanban-view-prd.txt",
            "parsedDate": "2025-06-01T07:27:35.658Z",
            "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
            "fileSize": 18300
          }
        }
      ],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/kanban-view-prd.txt",
        "fileName": "kanban-view-prd.txt",
        "parsedDate": "2025-06-01T07:27:35.658Z",
        "fileHash": "12f0f1db4cda4f5ad8a71c57a66d919f3e4b97458b4505e3b1b700180108c880",
        "fileSize": 18300
      }
    },
    {
      "id": 39,
      "title": "Implement Core PRD Directory Structure",
      "description": "Establish the core directory structure for PRD management, including 'pending', 'in-progress', 'done', 'archived', and 'templates' folders, along with the central 'prds.json' file.",
      "details": "Create the `/prd/` root directory. Inside, create subdirectories: `/prd/pending`, `/prd/in-progress`, `/prd/done`, `/prd/archived`, and `/prd/templates`. Initialize an empty `prds.json` file at `/prd/prds.json` with the base metadata structure as defined in the PRD.",
      "testStrategy": "Verify that all specified directories are created and `prds.json` exists and is accessible. Check initial content of `prds.json` for correct structure.",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Core PRD Directory Structure",
          "description": "Create the main 'prd' directory and its immediate subdirectories: 'specs', 'assets', and 'docs'.",
          "dependencies": [],
          "details": "This involves using `mkdir` or equivalent commands to establish the foundational directory structure for the PRD.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 2,
          "title": "Initialize Main PRD File",
          "description": "Create an empty 'main.md' file within the 'prd' directory.",
          "dependencies": [
            1
          ],
          "details": "This file will serve as the primary entry point for the Product Requirements Document. Use `touch` or similar to create the empty file.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 3,
          "title": "Verify PRD Directory Structure and File",
          "description": "Confirm that all specified directories and the 'main.md' file have been created correctly.",
          "dependencies": [
            1,
            2
          ],
          "details": "This step involves listing the contents of the 'prd' directory and its subdirectories to ensure everything is in place as expected. Use `ls -R prd` or similar commands.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        }
      ],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
        "fileName": "prd-tracking-meta.txt",
        "parsedDate": "2025-06-01T09:56:53.019Z",
        "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
        "fileSize": 8619
      }
    },
    {
      "id": 40,
      "title": "Develop PRD Metadata Schema and Management",
      "description": "Design and implement the `prds.json` schema to store comprehensive metadata for each PRD, including ID, title, status, file paths, linked tasks, and task statistics.",
      "details": "Create a Python class or data structure representing the PRD metadata as per the `prds.json` schema in the PRD. Implement functions to read from and write to `prds.json` ensuring data integrity and thread-safe operations. Include fields for `id`, `title`, `fileName`, `status`, `complexity`, `createdDate`, `lastModified`, `filePath`, `fileHash`, `fileSize`, `description`, `tags`, `linkedTaskIds`, `taskStats`, `estimatedEffort`, and `priority`. The `taskStats` object should include `totalTasks`, `completedTasks`, `pendingTasks`, `inProgressTasks`, and `completionPercentage`.",
      "testStrategy": "Create dummy PRD metadata and save it to `prds.json`. Read the data back and assert that all fields are correctly stored and retrieved. Test concurrent read/write operations to ensure data consistency.",
      "priority": "high",
      "dependencies": [
        39
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Define Core PRD Metadata Schema",
          "description": "Establish the initial structure and data types for the PRD metadata schema, including mandatory and optional fields, their types (string, integer, date, enum, etc.), and any initial constraints.",
          "dependencies": [],
          "details": "Identify key PRD attributes like ID, Title, Version, Status, Author, CreationDate, LastModifiedDate, etc. Consider using a schema definition language (e.g., JSON Schema, Protobuf IDL).",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 2,
          "title": "Implement Schema Management and Validation",
          "description": "Develop mechanisms to manage schema versions, validate incoming PRD metadata against the defined schema, and handle schema evolution (e.g., adding new fields, modifying existing ones).",
          "dependencies": [
            1
          ],
          "details": "Include functions for schema registration, retrieval, and validation. Consider backward and forward compatibility for schema changes.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 3,
          "title": "Develop PRD Metadata Read Functions",
          "description": "Implement functions for reading PRD metadata from the persistent storage. This includes functions for retrieving single records, lists, and potentially filtered or paginated results.",
          "dependencies": [
            1
          ],
          "details": "Focus on efficient data retrieval and deserialization into the defined schema structure. Consider indexing strategies for performance.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 4,
          "title": "Develop PRD Metadata Write Functions",
          "description": "Implement functions for writing (creating, updating, deleting) PRD metadata to the persistent storage. Ensure data integrity constraints are enforced during write operations.",
          "dependencies": [
            1,
            2
          ],
          "details": "Include validation before write operations. Implement atomic operations where necessary to prevent partial updates. Handle error conditions gracefully.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 5,
          "title": "Implement Data Integrity and Consistency Checks",
          "description": "Develop and integrate mechanisms to ensure the integrity and consistency of PRD metadata, including referential integrity, uniqueness constraints, and data type enforcement.",
          "dependencies": [
            4
          ],
          "details": "This might involve database-level constraints, application-level validation rules, and periodic data audits. Define rollback strategies for failed transactions.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 6,
          "title": "Implement Thread Safety for Metadata Operations",
          "description": "Ensure that all read and write operations on the PRD metadata are thread-safe to prevent race conditions and data corruption in concurrent environments.",
          "dependencies": [
            3,
            4
          ],
          "details": "Utilize appropriate synchronization primitives (e.g., locks, mutexes, semaphores) or concurrent data structures. Design for high concurrency where possible.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        }
      ],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
        "fileName": "prd-tracking-meta.txt",
        "parsedDate": "2025-06-01T09:56:53.019Z",
        "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
        "fileSize": 8619
      }
    },
    {
      "id": 41,
      "title": "Enhance Task-to-PRD Linking",
      "description": "Enhance the existing task structure to include a `prdSource` field, linking tasks directly to their associated PRDs with detailed metadata.",
      "details": "Modify the existing task data structure to incorporate the `prdSource` object. This object should contain `prdId`, `fileName`, `filePath`, `fileHash`, and `parsedDate`. Ensure that when a task is created or updated, this `prdSource` information is correctly populated and maintained.",
      "testStrategy": "Create new tasks and link them to existing PRDs. Verify that the `prdSource` field in the task object is correctly populated with the PRD's metadata. Update linked tasks and confirm `prdSource` remains consistent.",
      "priority": "high",
      "dependencies": [
        40
      ],
      "status": "pending",
      "subtasks": [],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
        "fileName": "prd-tracking-meta.txt",
        "parsedDate": "2025-06-01T09:56:53.019Z",
        "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
        "fileSize": 8619
      }
    },
    {
      "id": 42,
      "title": "Implement Automated PRD Status Management",
      "description": "Implement the core logic for automatically updating PRD statuses ('pending', 'in-progress', 'done') based on the completion percentage of linked tasks.",
      "details": "Develop a background process or a triggered function that monitors the status of tasks linked to a PRD. When the first linked task changes to 'in-progress', update the PRD status to 'in-progress'. When ALL linked tasks reach 'done' status (100% completion), update the PRD status to 'done'. This process should update the `taskStats` in the `prds.json` entry for the corresponding PRD. Consider using a file watching mechanism for efficiency.",
      "testStrategy": "Create a PRD with linked tasks. Change task statuses (e.g., one to 'in-progress', then all to 'done') and verify that the PRD status in `prds.json` updates automatically and correctly. Test edge cases like no linked tasks or tasks with mixed statuses.",
      "priority": "high",
      "dependencies": [
        41
      ],
      "status": "pending",
      "subtasks": [],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
        "fileName": "prd-tracking-meta.txt",
        "parsedDate": "2025-06-01T09:56:53.019Z",
        "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
        "fileSize": 8619
      }
    },
    {
      "id": 43,
      "title": "Develop Automated PRD File Movement",
      "description": "Develop the functionality for automatically moving PRD files between status-based directories (`/prd/pending`, `/prd/in-progress`, `/prd/done`) while preserving filenames and ensuring atomic operations.",
      "details": "Create a module responsible for moving PRD files. This module should be triggered by PRD status changes. Implement atomic file operations (e.g., copy then delete, or rename) to prevent data loss. Ensure original filenames are preserved. Implement a backup mechanism before any file movement occurs.",
      "testStrategy": "Change PRD statuses to trigger file moves. Verify that the PRD file is moved to the correct directory and its `filePath` in `prds.json` is updated. Confirm original filenames are maintained and no data loss occurs during moves. Test backup creation.",
      "priority": "high",
      "dependencies": [
        42
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Automated PRD File Movement Module",
          "description": "Create a high-level design document for the automated PRD file movement module, outlining its architecture, components, interfaces, and overall workflow. This includes defining input/output specifications and error handling strategies.",
          "dependencies": [],
          "details": "Focus on modularity and extensibility. Consider using a state machine for file processing.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 2,
          "title": "Implement Atomic File Operations",
          "description": "Develop and integrate functions for atomic file operations (e.g., move, copy, delete) to ensure data integrity during file transfers. This involves using temporary files and renaming for 'move' operations to prevent partial file states.",
          "dependencies": [
            1
          ],
          "details": "Utilize OS-level atomic operations where available. Implement robust error handling and rollback mechanisms.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 3,
          "title": "Preserve Filename and Path Integrity",
          "description": "Ensure that original filenames and relative path structures are preserved during the automated movement process. This includes handling special characters and long path names.",
          "dependencies": [
            2
          ],
          "details": "Implement robust path manipulation and validation logic. Test with various filename conventions.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 4,
          "title": "Develop Robust Backup Mechanism",
          "description": "Design and implement a comprehensive backup mechanism for PRD files before they are moved. This should include configurable backup locations, retention policies, and verification of backup integrity.",
          "dependencies": [
            1
          ],
          "details": "Consider incremental vs. full backups. Implement checksum verification for backed-up files.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 5,
          "title": "Integrate File Movement with Backup System",
          "description": "Combine the atomic file movement logic with the robust backup mechanism, ensuring that a successful backup occurs before any file movement is attempted, and that rollback is possible in case of failure.",
          "dependencies": [
            3,
            4
          ],
          "details": "Implement a transaction-like approach where backup is the first step, followed by movement. Define clear rollback procedures.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 6,
          "title": "Implement Monitoring and Logging",
          "description": "Develop comprehensive logging for all file movement and backup operations, including success/failure status, timestamps, and detailed error messages. Implement monitoring alerts for critical failures.",
          "dependencies": [
            5
          ],
          "details": "Use a structured logging framework. Integrate with existing monitoring systems if applicable.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        }
      ],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
        "fileName": "prd-tracking-meta.txt",
        "parsedDate": "2025-06-01T09:56:53.019Z",
        "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
        "fileSize": 8619
      }
    },
    {
      "id": 44,
      "title": "Extend CLI with PRD Management Commands",
      "description": "Extend the TaskMaster CLI with new commands for listing, managing status, showing details, and synchronizing PRDs.",
      "details": "Implement the following CLI commands: \n- `task-master prd list [--status pending|in-progress|done] [--format table|json]` to display PRDs based on status and format.\n- `task-master prd status --id <prd-id> --status <new-status> [--force]` to manually update PRD status with validation and audit trail.\n- `task-master prd show --id <prd-id> [--include-tasks] [--include-history]` to display detailed PRD information, including linked tasks and version history.\n- `task-master prd sync [--id <prd-id>] [--force]` to force synchronization of PRD status with linked tasks.",
      "testStrategy": "Execute each new CLI command with various parameters. Verify correct output for `list` and `show` commands. Test `status` command for valid and invalid status transitions, and `sync` for correct status updates. Ensure `--force` flag behaves as expected.",
      "priority": "high",
      "dependencies": [
        43
      ],
      "status": "pending",
      "subtasks": [],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
        "fileName": "prd-tracking-meta.txt",
        "parsedDate": "2025-06-01T09:56:53.019Z",
        "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
        "fileSize": 8619
      }
    },
    {
      "id": 45,
      "title": "Integrate PRD Features with Kanban and Interactive Menu",
      "description": "Integrate PRD filtering and viewing options into the existing Kanban board and add a new 'PRD Management' section to the interactive menu.",
      "details": "Modify the Kanban board to include filtering options: 'View All Tasks', 'View Tasks by PRD' (allowing selection of a specific PRD), and 'View Tasks by PRD Status' (filtering by pending/in-progress/done PRDs). Add a new '📄 PRD Management' section to the main interactive menu, providing options to list PRDs, show details, update status, sync, and archive.",
      "testStrategy": "Access the Kanban board and verify that the new PRD filtering options are available and function correctly. Navigate through the interactive menu to the new 'PRD Management' section and test each option for correct functionality and display.",
      "priority": "medium",
      "dependencies": [
        44
      ],
      "status": "pending",
      "subtasks": [],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
        "fileName": "prd-tracking-meta.txt",
        "parsedDate": "2025-06-01T09:56:53.019Z",
        "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
        "fileSize": 8619
      }
    },
    {
      "id": 46,
      "title": "Develop PRD Migration System",
      "description": "Develop a migration system to onboard existing PRDs into the new structured directory and metadata management system without data loss.",
      "details": "Implement the `task-master prd migrate [--dry-run] [--source <path>] [--backup]` command. This system should scan a specified source path for existing PRD files, parse their content to extract relevant metadata, create corresponding entries in `prds.json`, and move the files to the appropriate initial status directory (e.g., `/prd/pending`). Include a dry-run mode and a backup option to prevent data loss.",
      "testStrategy": "Create a set of mock existing PRD files in a separate directory. Run the migration command with `--dry-run` to verify parsing and proposed changes. Then, run without `--dry-run` and with `--backup` to ensure successful migration, correct `prds.json` updates, and backup creation. Verify no data loss.",
      "priority": "high",
      "dependencies": [
        40,
        43
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Define PRD File Parsing Strategy",
          "description": "Determine the approach for parsing existing PRD files, considering various formats (e.g., Markdown, plain text) and potential inconsistencies. Identify key sections and data points to extract.",
          "dependencies": [],
          "details": "Research common PRD structures. Outline regular expressions or parsing libraries to use. Consider edge cases for missing or malformed data.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 2,
          "title": "Implement Metadata Extraction Logic",
          "description": "Develop code to extract relevant metadata (e.g., title, version, author, date, status) from the parsed PRD files based on the defined strategy.",
          "dependencies": [
            1
          ],
          "details": "Write functions to identify and extract specific metadata fields. Handle cases where metadata might be implicit or require inference.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 3,
          "title": "Design `prds.json` Schema",
          "description": "Define the structure and fields for the new `prds.json` file, ensuring it can accommodate all extracted metadata and future requirements.",
          "dependencies": [
            2
          ],
          "details": "Specify data types, required/optional fields, and relationships within the JSON schema. Consider how to link to the actual PRD file.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 4,
          "title": "Develop `prds.json` Entry Creation",
          "description": "Implement the logic to transform extracted metadata into entries conforming to the `prds.json` schema and append them to the `prds.json` file.",
          "dependencies": [
            2,
            3
          ],
          "details": "Write functions to map extracted data to the `prds.json` fields. Ensure proper serialization and handling of existing `prds.json` content.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 5,
          "title": "Implement File Movement Logic",
          "description": "Develop the functionality to move the original PRD files to their new, organized locations within the system.",
          "dependencies": [
            4
          ],
          "details": "Define the new file naming convention and directory structure. Implement file system operations for moving files, including error handling.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 6,
          "title": "Add `--dry-run` Functionality",
          "description": "Integrate a `--dry-run` option to simulate the migration process without making any actual changes to files or `prds.json`.",
          "dependencies": [
            5
          ],
          "details": "Modify file movement and `prds.json` update logic to print intended actions instead of executing them when `--dry-run` is active.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 7,
          "title": "Add `--backup` Functionality",
          "description": "Implement a `--backup` option to create a backup of original PRD files and the `prds.json` file before performing the migration.",
          "dependencies": [
            5
          ],
          "details": "Develop logic to copy original files and `prds.json` to a designated backup directory before any modifications occur.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        }
      ],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
        "fileName": "prd-tracking-meta.txt",
        "parsedDate": "2025-06-01T09:56:53.019Z",
        "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
        "fileSize": 8619
      }
    },
    {
      "id": 47,
      "title": "Implement PRD Version Control and History",
      "description": "Implement version control for PRDs, allowing snapshots, tracking modifications, and providing rollback capabilities.",
      "details": "Create a system to maintain PRD version snapshots in `/prd/archived/versions/`. This should involve creating a new snapshot whenever a PRD file is modified or its status changes. Each snapshot should include a timestamp and a description of the change. Implement a rollback capability to restore a previous version of a PRD file and update its metadata accordingly.",
      "testStrategy": "Modify a PRD file and change its status multiple times. Verify that new versions are created in the `archived/versions` directory with correct timestamps. Attempt to rollback to a previous version and confirm that the PRD file content and its metadata in `prds.json` are correctly restored.",
      "priority": "medium",
      "dependencies": [
        43
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Snapshot Trigger Logic",
          "description": "Define the events or conditions that will trigger the creation of a new PRD version snapshot. This includes manual triggers, automated triggers (e.g., on commit, on specific time intervals, on significant content changes), and the logic for determining when a change is 'significant' enough to warrant a new version.",
          "dependencies": [],
          "details": "Consider triggers like 'on save', 'on publish', 'on major content update', 'daily backup'. Define thresholds for 'major content update' (e.g., percentage of content changed, specific sections modified).",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 2,
          "title": "Implement Snapshot Timestamping and Description Capture",
          "description": "Develop the mechanism to automatically capture a timestamp for each snapshot and prompt/allow users to add a descriptive message for the version. This metadata is crucial for understanding the history.",
          "dependencies": [
            1
          ],
          "details": "Timestamp format (ISO 8601 recommended). User input field for version description. Consider auto-generating a description if none is provided (e.g., 'Auto-save on YYYY-MM-DD HH:MM').",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 3,
          "title": "Define Storage Strategy for `archived/versions`",
          "description": "Determine the file structure and naming conventions within the `archived/versions` directory for storing PRD snapshots. This includes how individual versions are organized (e.g., by timestamp, by version number, by project).",
          "dependencies": [
            1,
            2
          ],
          "details": "Consider a hierarchical structure: `archived/versions/{project_id}/{prd_id}/{timestamp}/`. Decide on file formats for storing PRD content (e.g., Markdown, JSON, HTML).",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 4,
          "title": "Develop Snapshot Creation Mechanism",
          "description": "Implement the core logic to take the current state of a PRD, apply the timestamp and description, and save it to the designated `archived/versions` location according to the defined storage strategy.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "This involves reading the current PRD content, creating a new directory/file for the version, and writing the content along with metadata (timestamp, description). Ensure atomic operations to prevent data corruption.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 5,
          "title": "Implement Version History Listing",
          "description": "Create a function or interface that can list all available versions for a given PRD, displaying their timestamps and descriptions to the user.",
          "dependencies": [
            3,
            4
          ],
          "details": "Read directory contents of `archived/versions/{project_id}/{prd_id}/` and parse metadata files/directories to present a chronological list of versions.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 6,
          "title": "Design Rollback Mechanism - Content Restoration",
          "description": "Define the process for restoring the content of a PRD to a specific historical version. This involves retrieving the old content from `archived/versions` and replacing the current PRD content.",
          "dependencies": [
            3,
            5
          ],
          "details": "Identify the target version's content. Overwrite the current PRD file with the content from the selected historical version. Consider backup of current version before rollback.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 7,
          "title": "Design Rollback Mechanism - Metadata and State Restoration",
          "description": "Beyond just content, define how associated metadata (e.g., status, assigned owner, tags) and any other relevant state are restored or updated during a rollback.",
          "dependencies": [
            6
          ],
          "details": "Determine which metadata fields are versioned and how they are stored with each snapshot. Implement logic to update the active PRD's metadata to match the rolled-back version's metadata.",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        },
        {
          "id": 8,
          "title": "Implement Rollback Execution and Confirmation",
          "description": "Develop the user interface and backend logic for executing a rollback, including confirmation prompts and error handling. Ensure the process is robust and reversible if necessary.",
          "dependencies": [
            6,
            7
          ],
          "details": "User confirmation dialog before rollback. Logging of rollback operations. Mechanism to potentially 'undo' a rollback (e.g., by creating a new snapshot of the state just before rollback).",
          "status": "pending",
          "prdSource": {
            "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
            "fileName": "prd-tracking-meta.txt",
            "parsedDate": "2025-06-01T09:56:53.019Z",
            "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
            "fileSize": 8619
          }
        }
      ],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
        "fileName": "prd-tracking-meta.txt",
        "parsedDate": "2025-06-01T09:56:53.019Z",
        "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
        "fileSize": 8619
      }
    },
    {
      "id": 48,
      "title": "Update AI Agent Guidelines for PRD Management",
      "description": "Update AI agent guidelines and rules to incorporate the new PRD organization patterns, automated status tracking, and bidirectional linking.",
      "details": "Modify `.augment-guidelines`, `.cursor/rules/`, and `.roo/` rules to reflect the new PRD lifecycle management system. This includes instructing AI agents on: \n- How to organize PRD files within the new directory structure.\n- How to leverage automated status tracking based on task completion.\n- The importance of maintaining bidirectional task-to-PRD references.\n- Guidelines for PRD creation using templates and proper metadata population.",
      "testStrategy": "Review the updated AI agent guidelines files to ensure all new PRD management rules are clearly documented. Simulate AI agent interactions (if possible) to confirm they adhere to the new guidelines for PRD organization and linking.",
      "priority": "low",
      "dependencies": [
        41,
        42
      ],
      "status": "pending",
      "subtasks": [],
      "prdSource": {
        "filePath": "C:/laragon/www/taskmaster-ai/scripts/prd-tracking-meta.txt",
        "fileName": "prd-tracking-meta.txt",
        "parsedDate": "2025-06-01T09:56:53.019Z",
        "fileHash": "53ecce97f9bc04112843bd533d798ab370c391bbf3172c364369f601aac6d055",
        "fileSize": 8619
      }
    }
  ]
}
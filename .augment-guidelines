# TaskMaster AI Workspace Guidelines for Augment

## Project Overview
This is a TaskMaster AI project - an AI-driven task management system designed for ambitious development projects. TaskMaster helps break down complex requirements into manageable, well-structured tasks with dependencies, subtasks, and detailed implementation guidance.

## Core Technologies & Architecture
- **Runtime**: Node.js with ES modules
- **CLI Framework**: Commander.js for command-line interface
- **Interactive UI**: Inquirer.js with chalk for colored output and boxen for styled containers
- **AI Integration**: Multiple AI providers (Anthropic Claude, OpenAI, Google Gemini, Perplexity, xAI, OpenRouter)
- **Data Storage**: JSON files for task data (`tasks/tasks.json`)
- **Configuration**: `.taskmasterconfig` for AI models, `.env` for API keys
- **MCP Integration**: Model Context Protocol server for editor integrations (Cursor, Windsurf, VS Code)

## TaskMaster-Specific Patterns

### Task Structure
- Tasks have IDs, titles, descriptions, status, dependencies, and optional subtasks
- Subtasks use dot notation (e.g., task 5.2 is subtask 2 of task 5)
- Status values: pending, in-progress, done, review, blocked, deferred, cancelled
- Dependencies are arrays of task IDs that must be completed first

### Command Patterns
- All commands support both CLI and MCP interfaces
- Use `--append` flag when adding tasks to existing projects
- Commands that modify tasks should regenerate markdown files automatically
- AI-powered commands (parse-prd, update, expand) require API keys and can take time

### File Organization
- `tasks/tasks.json` - Main task data file
- `tasks/task_XXX.txt` - Individual task markdown files
- `scripts/` - PRD files and utilities
- `.cursor/rules/` - Cursor AI integration rules
- `mcp-server/` - Model Context Protocol server
- `src/menu/` - Interactive menu system

## Development Guidelines

### Code Style
- Use ES modules (import/export) throughout
- Prefer async/await over promises
- Use descriptive variable names and clear function signatures
- Add JSDoc comments for complex functions
- Handle errors gracefully with try-catch blocks

### Interactive Menu System
- Use inquirer.js for user prompts with validation
- Implement breadcrumb navigation with sessionState.menuPath
- Provide colored output using chalk (blue for info, green for success, red for errors, yellow for warnings)
- Include "Back to Main Menu" options in sub-menus
- Show real-time project information in menu headers

### AI Integration Best Practices
- Always check for existing tasks before parsing PRD - offer append vs replace options
- Validate API keys before making AI calls
- Provide progress feedback for long-running AI operations
- Use research models for complex analysis when available
- Handle AI failures gracefully with fallback options

### Error Handling
- Log errors with context using the logging system
- Provide clear, actionable error messages to users
- Offer recovery options when operations fail
- Validate user input before processing

### Testing Approach
- Test CLI commands with various parameter combinations
- Verify interactive menu navigation and error handling
- Test AI integration with mock responses when possible
- Validate task data integrity after operations

## TaskMaster Command Reference

### Essential Commands
- `task-master init` - Initialize new project
- `task-master menu` - Launch interactive menu (recommended)
- `task-master parse-prd --input=<file>` - Generate tasks from PRD
- `task-master list` - Show all tasks
- `task-master next` - Find next available task
- `task-master set-status --id=<id> --status=<status>` - Update task status

### Task Management
- `task-master add-task --prompt="<description>"` - Add new task
- `task-master update-task --id=<id> --prompt="<context>"` - Update specific task
- `task-master expand --id=<id>` - Break task into subtasks
- `task-master remove-task --id=<id>` - Delete task

### Advanced Features
- `task-master analyze-complexity` - Analyze task complexity
- `task-master models --setup` - Configure AI models
- `task-master add-dependency --id=<id> --depends-on=<id>` - Add dependencies

## Best Practices for TaskMaster Development

### When Working with Tasks
- Always use the interactive menu (`task-master menu`) for better UX
- Check task dependencies before marking tasks as done
- Use subtasks to break down complex implementations
- Update task status regularly to track progress
- Add dependencies to ensure proper execution order

### When Modifying TaskMaster Code
- Test changes with the interactive menu system
- Ensure both CLI and MCP interfaces work consistently
- Validate error handling with invalid inputs
- Update documentation when adding new features
- Consider backward compatibility with existing task files

### AI Model Configuration
- Set up multiple AI providers for redundancy
- Use research models for complex analysis tasks
- Configure fallback models for reliability
- Store API keys securely in `.env` file
- Test AI integration before deploying changes

## File Naming Conventions
- Use kebab-case for CLI command files
- Use camelCase for JavaScript functions and variables
- Use descriptive names for task files (task_001.txt, task_002.txt, etc.)
- Prefix utility functions with their purpose (validate-, format-, parse-)

## Integration Guidelines
- MCP tools should mirror CLI functionality
- Maintain consistency between interactive menu and direct commands
- Provide clear progress feedback for long-running operations
- Handle cross-platform differences (Windows vs Unix)
- Support both local and global installations

## Common Anti-Patterns to Avoid
- Don't manually edit `tasks.json` - use TaskMaster commands
- Don't skip dependency validation when adding tasks
- Don't ignore error handling in AI operations
- Don't hardcode file paths - use path resolution utilities
- Don't forget to regenerate task files after JSON changes

## When Implementing New Features
- Follow the existing command pattern (CLI + MCP + interactive menu)
- Add comprehensive error handling and validation
- Include progress feedback for user operations
- Update both documentation and help text
- Test with various project configurations
- Consider impact on existing task data structures
